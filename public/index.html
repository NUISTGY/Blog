<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Do what you want to do !"><meta name="keywords" content><meta name="author" content="GeYu"><meta name="copyright" content="GeYu"><title>Do not go gentle into that good night ~ | Yu's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="http://r.photo.store.qq.com/psc?/V14eJTFY137vJk/cnQ2D7YjAZ5R6pY0fmc9jgCqVB3ImjsxGUOZ.vc77kDsEnIVTLf2mSSJ6Y6vFW94Mcab*2OmXqY9iWaksXwrBNsvyKd0aWWJwyMTtKd1DOQ!/r"></div><div class="author-info__name text-center">GeYu</div><div class="author-info__description text-center">Do what you want to do !</div><div class="follow-button"><a href="https://github.com/NUISTGY">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">84</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">46</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">21</span></a></div></div></div><nav id="nav" style="background-image: url(https://w.wallhaven.cc/full/3z/wallhaven-3zgz2y.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yu's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="site-info"><div id="site-title">Yu's Blog</div><div id="site-sub-title">Do not go gentle into that good night ~</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/12/Nginx_Reverse_proxy/">Nginx 反向代理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h1><p><strong>引言</strong></p>
<p>Nginx 如何变成一个代理服务器？Nginx 又如何将客户端的请求转发给其他的服务器？本内容将学习 Nginx 的反向代理知识。</p>
<hr>
<h2 id="反向代理概述"><a href="#反向代理概述" class="headerlink" title="反向代理概述"></a>反向代理概述</h2><p>关于正向代理和反向代理，在 <a href="/pages/9551ee/#名词解释">Nginx - 介绍</a> 已经通过一张图详细的介绍过了，简而言之就是正向代理代理的对象是客户端，反向代理代理的是服务端，这是两者之间最大的区别。</p>
<p>Nginx 即可以实现正向代理，也可以实现反向代理。</p>
<p>我们先来通过一个小案例演示下 Nginx 正向代理的简单应用。</p>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>先提需求：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.53oygoz19gc0.webp" alt="image"></p>
<ol>
<li>服务端的设置：</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">'client send request=&gt;clientIp=<span class="variable">$remote_addr</span> serverIp=<span class="variable">$host</span>'</span>;</span><br><span class="line">	server&#123;</span><br><span class="line">		<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">		<span class="attribute">server_name</span>	localhost;</span><br><span class="line">		<span class="attribute">access_log</span> logs/access.log main;</span><br><span class="line">		<span class="attribute">location</span> / &#123;</span><br><span class="line">			<span class="attribute">root</span> html;</span><br><span class="line">			<span class="attribute">index</span> index.html index.htm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用客户端访问服务端：<code>http://192.168.200.133</code>，打开日志查看结果</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.16ifxal7swyk.webp" alt="image"></p>
<ol start="3">
<li>代理服务器设置：</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">82</span>;</span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">8.8.8.8</span>;   <span class="comment"># 设置 DNS 的 IP，用来解析 proxy_pass 中的域名</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://<span class="variable">$host</span><span class="variable">$request_uri</span>;   <span class="comment"># proxy_pass 实现正向代理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>proxy_pass</code> 后面有讲解。</p>
<ol start="4">
<li>客户端配置代理服务器的 IP(192.168.200.146)和 Nginx 配置监听的端口(82)</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.3yx93qbazra0.webp" alt="image"></p>
<ol start="5">
<li>设置完成后，再次通过浏览器访问服务端</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6litsat09000.webp" alt="image"></p>
<p>通过对比，上下两次的日志记录，会发现虽然我们是客户端访问服务端，但是使用了代理，那么服务端能看到的只是代理发送过去的请求，这样就使用 Nginx 实现了正向代理的设置。</p>
<p>但是 Nginx 正向代理，在实际的应用中不是特别多，所以我们简单了解下，接下来我们继续学习 Nginx 的反向代理，这是 Nginx 比较重要的一个功能。</p>
<h2 id="反向代理语法配置"><a href="#反向代理语法配置" class="headerlink" title="反向代理语法配置"></a>反向代理语法配置</h2><p>Nginx 反向代理模块的指令是由 <code>ngx_http_proxy_module</code> 模块进行解析，该模块在安装 Nginx 的时候已经自动加载到 Nginx 中了，接下来我们把反向代理中的常用指令一一介绍下：</p>
<ul>
<li>proxy_pass：配置代理的服务器地址</li>
<li>proxy_set_header：转发给被代理服务器时，设置一些请求头信息</li>
<li>proxy_redirect：防止客户端可以看到被代理服务器的地址</li>
</ul>
<p>这里只介绍三个指令，关于反向代理的指令非常多，想要了解更多，请前往 <a href="https://nginx.org/en/docs/stream/ngx_stream_proxy_module.html" target="_blank" rel="noopener">Nginx 反向代理文档</a></p>
<h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h3><p>该指令用来设置被代理服务器地址，可以是主机名称、IP 地址加端口号形式，没有默认值。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_pass &lt;URL&gt;;</td>
<td>—</td>
<td>location</td>
</tr>
</tbody></table>
<p><code>URL</code>：为要设置的被代理服务器地址，包含传输协议(<code>http</code>、<code>https://</code>)、主机名称或 IP 地址加端口号、URI 等要素。</p>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_pass</span> http://www.baidu.com;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="attribute">location</span> /server &#123;</span><br><span class="line">    <span class="comment"># 结尾不加斜杠</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.200.146;</span><br><span class="line">    <span class="comment"># 访问的是：http://192.168.200.146/server/index.html</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结尾加斜杠</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.200.146/;</span><br><span class="line">    <span class="comment"># 访问的是：http://192.168.200.146/index.html</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>实例</strong></p>
</blockquote>
<p>准备两台服务器或者按照 Linux 系统的虚拟机，这里是 <code>192.168.200.133</code> 和 <code>192.168.200.146</code>，为了方便，我们称前者为服务器 A，后者为服务器 B。</p>
<ol>
<li>在服务器 A 的 Nginx 配置文件添加如下内容：</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://192.168.200.146;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当客户端请求服务器 A <code>http://192.168.200.133</code>，它会转发给服务器 B，此时的服务器 A 就是一个代理的角色。</p>
<p>访问服务器 A，我们看到 Nginx 的欢迎界面其实是服务器 B 的 Nginx，可以在服务器 B 的 Nginx 欢迎页面添加新的内容：<code>I am 146</code>，再次访问服务器 A，效果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.4ai1u3uxs940.webp" alt="image"></p>
<p><strong>在编写 proxy_pass 的时候，后面的值要不要加 /?</strong></p>
<p>这是看情况的。</p>
<p>接下来通过例子来说明提到的问题：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 下面两个地址加不加斜杠，效果都一样，因为 location 后的 / 会添加在代理地址后面</span></span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146/;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /server &#123;</span><br><span class="line">        <span class="comment"># 下面两个地址必须加斜杠，因为 location 后的 /server 会添加在代理地址后面，第一个将没有 / 结尾</span></span><br><span class="line">		<span class="comment">#proxy_pass http://192.168.200.146;</span></span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146/;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 上面的 location：当客户端访问 http://localhost/server/index.html</span></span><br><span class="line"><span class="comment"># 第一个 proxy_pass 就变成了 http://localhost/server/index.html</span></span><br><span class="line"><span class="comment"># 第二个 proxy_pass 就变成了 http://localhost/index.html 效果就不一样了。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个 location（第 4 行代码）：当客户端访问 <code>http://localhost/index.html</code>，两个 <code>proxy_pass</code> 效果是一样的，因为 location 后的 <code>/</code> 会添加在代理地址后面，所以有没有 <code>/</code>，效果都一样。</p>
</li>
<li><p>第一个 location（第 14 行代码）：当客户端访问 <code>http://localhost/server/index.html</code>，这个时候，第一个 proxy_pass 就变成了 <code>http://192.168.200.146/server/index.html</code>，第二个 proxy_pass 就变成了 <code>http://192.168.200.146/index.html</code> 效果就不一样了</p>
<p>如果不以 <code>/</code> 结尾，则 location 后的 <code>/server</code> 会添加在地址后面，所以第一个 proxy_pass 因为没有 <code>/</code> 结尾而被加上 <code>/server</code>，而第二个自带了 <code>/</code> ，所以不会添加 <code>/server</code>。</p>
</li>
</ul>
<p>上面的例子仅仅针对：访问任意请求如 <code>/server</code> 时，想要代理到其他服务器的首页，则加 <code>/</code>，否则你如果真的想访问 <code>/server</code> 下的资源，那么不要加 <code>/</code>。</p>
<p>所以加了 <code>/</code> 后，请求的是服务器根目录下的资源。</p>
<h3 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a>proxy_set_header</h3><p>该指令可以更改 Nginx 服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器。默认值是发送代理服务器的地址和 close。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.4bt7qzhbz1i0.webp" alt="image"></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_set_header &lt;field&gt; &lt;value&gt;;</td>
<td>proxy_set_header Host $proxy_host; proxy_set_header Connection close;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>需要注意的是，如果想要看到结果，必须在被代理的服务器上来获取添加的头信息。</p>
<blockquote>
<p><strong>实例</strong></p>
</blockquote>
<p>被代理服务器：服务器 B <code>192.168.200.146</code> 的 Nginx 配置文件内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$http_username</span>;    <span class="comment"># 获取代理服务器发送过来的 http 请求头的 username 值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理服务器: 服务器 A <code>192.168.200.133</code> 的 Nginx 配置文件内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> /server &#123;           <span class="comment"># 访问 /server 触发代理</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:8080/;  <span class="comment"># 配置服务器 B 的地址</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> username TOM;  <span class="comment"># 发送 key 为 username，value 为 TOM 的请求头给服务器 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问测试</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.398ksbw6rv20.webp" alt="image"></p>
<p>客户端访问的是服务器 A，服务器 A 会将请求转发给服务器 B，服务器 B 返回打印 TOM 的页面给服务器 A，服务器 A 最后返回给客户端。</p>
<h3 id="proxy-redirect"><a href="#proxy-redirect" class="headerlink" title="proxy_redirect"></a>proxy_redirect</h3><p>该指令是用来重置头信息中的『 Location 』和『 Refresh 』的值，防止客户端可以看到被代理服务器的地址。</p>
<p>因为客户端看到的返回结果是『 Location 』和『 Refresh 』的值，所以在到达代理服务器的时，将两个值修改掉，防止客户端直接看到被代理服务器的地址。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_redirect redirect replacement;<br> proxy_redirect default; <br>proxy_redirect off;</td>
<td>proxy_redirect default;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>为什么要用该指令？</strong></p>
</blockquote>
<p>首先说明一下思路：客户端通过代理服务器 A 访问服务器 B 的资源，但是服务器 B 不存在该资源，则会报错。此时我们不希望它直接返回报错页面给客户端，我们希望服务器 B 返回的是它的欢迎页面。那么如何做呢？</p>
<ul>
<li>首先在服务器 B 进行判断是否存在资源，不存在则返回自己的欢迎页面，即重定向到自己的欢迎页面地址并返回，此时浏览器的地址将会发生改变</li>
<li>代理服务器 A 收到服务器 B 的欢迎页面和地址，但是我们不能直接返回给客户端，因为它会暴露服务器 B 的地址，这是重定向的原因</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.a4tptcx6lbk.webp" alt="image"></p>
<ul>
<li>此时用到 <code>proxy_redirect</code> 指令，重置服务器 B 返回过来的『 Location 』和『 Refresh 』值，将两个值改为代理服务器 A 的某个地址</li>
<li>因为改为了代理服务器 A 的某个地址，所以代理服务器 A 根据这个地址又去获取理服务器 B 的欢迎页面地址，返回给客户端</li>
</ul>
<p>很绕，简单总结下：客户端通过 A 找 B 不存在的资源，B 不想返回报错页面，于是重定向到自己的欢迎页面地址并返回给 A，A 收到了页面和地址（正常情况不要接收地址，只接收页面），发现不能暴露 B 的地址，于是修改接收的 B 的地址为自己的某一个地址，这个地址会重新发送请求去获取 B 的欢迎页面地址，然后返回给客户端。</p>
<p>这里要明白 B 返回的是重定向后的欢迎页面，重定向后，浏览器地址栏会变成重定向的地址，所以 A 才会以自己的地址转发获取到 B 的地址，所以最后浏览器显示 A 的地址，看到的却是 B 的欢迎页面。</p>
<p>代码：</p>
<p>服务端 B <code>192.168.200.146</code></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8081</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">if</span> (!-f <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">    	<span class="attribute">return</span> <span class="number">302</span> http://192.168.200.146;   <span class="comment">#  2.如果请求的资源不存在，则重定向到服务器 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理服务端 A <code>192.168.200.133</code></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>  <span class="number">8081</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146:8081/;  <span class="comment"># 1.转发给服务器 B</span></span><br><span class="line">		<span class="attribute">proxy_redirect</span> http://192.168.200.146 http://192.168.200.133; <span class="comment"># 3.修改服务器 B 的地址</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 该 server 去请求服务器 B 的欢迎页面</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">192.168.200.133</span>;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146;  <span class="comment"># 4.重新发送请求给服务器 B，获取欢迎页面</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 6 行代码，当服务器 B 返回的是 <code>http://192.168.200.146</code>，为了不让它出现在浏览器的地址栏上，我们需要利用 <code>proxy_redirect</code> 将它修改为代理服务器 A 的地址，这个地址会以自己的地址重新访问服务器 B 的欢迎页面，最后返回给客户端。</p>
<p><strong>该指令的三组选项</strong></p>
<ul>
<li><p><code>proxy_redirect redirect replacement;</code></p>
<ul>
<li>redirect：被代理服务器返回的 Location 值</li>
<li>replacement：要替换 Location 的值</li>
</ul>
</li>
<li><p><code>proxy_redirect default;</code></p>
<ul>
<li><p>default：相比较第一组选项，default 仅仅提供了 <code>redirect</code> 和 <code>replacement</code> 的默认值</p>
<p>将本范围 location 块的 uri 变量作为 replacement。</p>
<p>将 proxy_pass 变量作为 redwadairect</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>  <span class="number">8081</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /server &#123; </span><br><span class="line">		<span class="attribute">proxy_pass</span> http://192.168.200.146:8081/;</span><br><span class="line">		<span class="attribute">proxy_redirect</span> default;  <span class="comment"># redirect 是 proxy_pass 的值：http://192.168.200.146:8081/</span></span><br><span class="line">        						 <span class="comment"># replacement 是 location 后的值：/server</span></span><br><span class="line">        <span class="comment"># 等价于：proxy_redirect http://192.168.200.146:8081/ /server</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>proxy_redirect off;</code></p>
<p>关闭 proxy_redirect 的功能</p>
</li>
</ul>
<h2 id="反向代理实战"><a href="#反向代理实战" class="headerlink" title="反向代理实战"></a>反向代理实战</h2><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.59ecpsonzxc0.webp" alt="image"></p>
<p>服务器 1，2，3 存在两种情况</p>
<ul>
<li>第一种情况: 三台服务器的内容不一样</li>
<li>第二种情况: 三台服务器的内容是一样</li>
</ul>
<p>第一种情况</p>
<ul>
<li><p>如果服务器 1、服务器 2 和服务器 3 的内容不一样，那我们可以根据用户请求来分发到不同的服务器。</p>
<p>服务器有限，只能以三个端口模拟三台服务器，实际上是一个 IP 对应一个服务器。</p>
<p>代理服务器配置文件内容：</p>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代理服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8082</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost; </span><br><span class="line">    <span class="attribute">location</span> /server1 &#123;    </span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:9001/;   <span class="comment"># 代理 server1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /server2 &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:9002/;   <span class="comment"># 代理 server2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> /server3 &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.200.146:9003/;   <span class="comment"># 代理 server3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器配置文件内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器</span></span><br><span class="line"><span class="comment"># server1</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">9001</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># server2</span></span><br><span class="line">server &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">9002</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># server3</span></span><br><span class="line">server &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">9003</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果服务器 1、服务器 2 和服务器 3 的内容是一样的，该如何处理?</p>
<p>请看负载均衡的相关内容，里面将进行详细的介绍。</p>
</li>
</ul>
<h2 id="斜杠总结"><a href="#斜杠总结" class="headerlink" title="斜杠总结"></a>斜杠总结</h2><p>这里将发送 <code>http://192.168.199.27/frx/xu</code> 请求。</p>
<p><strong>不带字符串情况</strong></p>
<table>
<thead>
<tr>
<th>案例</th>
<th>localtion</th>
<th>proxy_pass</th>
<th>匹配</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>/frx</td>
<td><a href="http://192.168.199.27" target="_blank" rel="noopener">http://192.168.199.27</a></td>
<td>/frx/xu</td>
</tr>
<tr>
<td>2</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27" target="_blank" rel="noopener">http://192.168.199.27</a></td>
<td>/frx/xu</td>
</tr>
<tr>
<td>3</td>
<td>/frx</td>
<td><a href="http://192.168.199.27/" target="_blank" rel="noopener">http://192.168.199.27/</a></td>
<td>//xu</td>
</tr>
<tr>
<td>4</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27/" target="_blank" rel="noopener">http://192.168.199.27/</a></td>
<td>/xu</td>
</tr>
</tbody></table>
<p>若 Nginx 会将原请求路径原封不动地转交给其他地址，如案例 3 和 4。</p>
<p><code>proxy_pass</code> 的 ip:port 后加了 <code>/</code>，代表去除掉请求和 location 的匹配的字符串，不加则追加全部请求到地址后面。</p>
<p><strong>带字符串情况</strong></p>
<table>
<thead>
<tr>
<th>案例</th>
<th>localtion</th>
<th>proxy_pass</th>
<th>匹配</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>/frx</td>
<td><a href="http://192.168.199.27/bing" target="_blank" rel="noopener">http://192.168.199.27/bing</a></td>
<td>/bing/xu</td>
</tr>
<tr>
<td>2</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27/bing" target="_blank" rel="noopener">http://192.168.199.27/bing</a></td>
<td>/bingxu</td>
</tr>
<tr>
<td>3</td>
<td>/frx</td>
<td><a href="http://192.168.199.27/bing/" target="_blank" rel="noopener">http://192.168.199.27/bing/</a></td>
<td>/bing//xu</td>
</tr>
<tr>
<td>4</td>
<td>/frx/</td>
<td><a href="http://192.168.199.27/bing/" target="_blank" rel="noopener">http://192.168.199.27/bing/</a></td>
<td>/bing/xu</td>
</tr>
</tbody></table>
<p><code>proxy_pass</code> 的 ip:port 后加了字符串，Nginx 会将匹配 location 的请求从「原请求路径」中剔除，再不匹配的字符串拼接到 proxy_pass 后生成「新请求路径」，然后将「新请求路径」转交给其他地址。</p>
<p>案例 2 中，<code>proxy_pass</code> 的 ip:port 后接了字符串，因此将 location 的 <code>/frx/</code> 从原请求路径 <code>/frx/xu</code> 中剔除，变为 <code>xu</code>，然后将 <code>xu</code> 拼接到 <code>http://192.168.1.48/bing</code> 后生成了新请求，因此其他地址收到的请求就是 <code>/bingxu</code>。</p>
<h2 id="Nginx安全控制"><a href="#Nginx安全控制" class="headerlink" title="Nginx安全控制"></a>Nginx安全控制</h2><p>关于 Web 服务器的安全是比较大的一个话题，里面所涉及的内容很多，Nginx 反向代理是如何来提升 Web 服务器的安全呢？</p>
<p>答案是：安全隔离。</p>
<h3 id="什么是安全隔离"><a href="#什么是安全隔离" class="headerlink" title="什么是安全隔离"></a>什么是安全隔离</h3><p>通过代理分开了客户端到应用程序服务器端的连接，实现了安全措施。在反向代理之前设置防火墙，仅留一个入口供代理服务器访问。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.3vhdv63nf9q0.webp" alt="image"></p>
<h3 id="如何使用SSL对流量加密"><a href="#如何使用SSL对流量加密" class="headerlink" title="如何使用SSL对流量加密"></a>如何使用SSL对流量加密</h3><p>翻译成大家能熟悉的说法就是将我们常用的 http 请求转变成 https 请求，那么这两个之间的区别简单的来说两个都是 HTTP 协议，只不过 https 是身披 SSL 外壳的 http.</p>
<p>HTTPS 是一种通过计算机网络进行安全通信的传输协议。它经由 HTTP 进行通信，利用 SSL/TLS 建立全通信，加密数据包，确保数据的安全性。</p>
<ul>
<li>SSL(Secure Sockets Layer)安全套接层</li>
<li>TLS(Transport Layer Security)传输层安全</li>
</ul>
<p>上述这两个是为网络通信提供安全及数据完整性的一种安全协议，TLS 和 SSL 在传输层和应用层对网络连接进行加密。</p>
<p>总结来说为什么要使用 https:</p>
<ul>
<li>http 协议是明文传输数据，存在安全问题，而 https 是加密传输，相当于 http + SSL，并且可以防止流量劫持。</li>
</ul>
<p>Nginx 默认不支持 https 开头的协议，如果要想使用 SSL，需要满足一个条件即需要添加一个模块 <code>--with-http_ssl_module</code>，而该模块在编译的过程中又需要 OpenSSL 的支持，OpenSSL 我们在 <a href="/middleware/Nginx/Nginx_install/#nginx环境安装">Nginx 安装</a> 已经准备好了。</p>
<h3 id="添加SSL支持"><a href="#添加SSL支持" class="headerlink" title="添加SSL支持"></a>添加SSL支持</h3><p>完成 <code>--with-http_ssl_module</code> 模块的增量添加。</p>
<ol>
<li>将原有 <code>/usr/local/nginx/sbin/nginx</code> 进行备份</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line">mv nginx nginx.backup</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看 <code>configure arguments</code> 的配置信息，拷贝出来</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝 configure arguments 后面的数据</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入 Nginx 的安装目录，执行 make clean 清空之前编译的内容</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span> /root/nginx/core/nginx-<span class="number">1</span>.<span class="number">20</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 configure 来配置参数，添加 <code>ngx_http_ssl_module</code> 模块，记得加上第（2）步拷贝的配置信息</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_ssl_module <span class="comment"># 记得添加 configure arguments 后的数据</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通过 make 模板进行编译</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将 objs 下面的 nginx 可执行文件移动到 <code>/usr/local/nginx/sbin</code> 下</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /opt/nginx/core/nginx-1.20.2/objs/nginx /usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在源码目录（安装包目录）下执行 <code>make upgrade</code> 进行升级，这个可以实现不停机添加新模块的功能</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx/core/nginx-1.20.2</span><br><span class="line">make upgrade</span><br></pre></td></tr></table></figure>

<h3 id="SSL相关指令"><a href="#SSL相关指令" class="headerlink" title="SSL相关指令"></a>SSL相关指令</h3><p>该模块的指令都是通过 <code>ngx_http_ssl_module</code> 模块来解析的，我们上一步已经添加了。</p>
<p>这里只介绍常用的几个指令，了解更多指令请前往 <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html" target="_blank" rel="noopener">ngx_http_ssl_module 模块文档</a>。</p>
<p><code>ssl</code> 指令用来在指定的服务器开启 HTTPS，默认关闭。可以使用 listen 443 ssl，这种方式更通用些。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl &lt;on |off&gt;;</td>
<td>ssl off;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p>ssl 默认监听的是 443 端口，所以使用下面的指令和 <code>ssl on</code> 效果一致，因为下面的指令能突出 sll 的监听端口，所以建议使用它。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ssl_certificate</code> 指令是为当前这个虚拟主机指定一个带有 PEM 格式证书的证书。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_certificate &lt;file&gt;;</td>
<td>—</td>
<td>http、server</td>
</tr>
</tbody></table>
<p><code>ssl_certificate_key</code> 指令用来指定 PEM secret key 文件的路径</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_ceritificate_key &lt;file&gt;;</td>
<td>—</td>
<td>http、server</td>
</tr>
</tbody></table>
<p><code>ssl_session_cache</code> 指令用来配置用于 SSL 会话的缓存</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_sesion_cache &lt;off | none | [builtin[:size]] [shared:name:size]&gt;</td>
<td>ssl_session_cache none;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p>选项介绍：</p>
<ul>
<li><p><code>off</code>：严格禁止使用会话缓存：Nginx 明确告诉客户端会话不能被重用</p>
</li>
<li><p><code>none</code>：禁止使用会话缓存，Nginx 告诉客户端会话可以被重用，但实际上并不在缓存中存储会话参数（任性，言语同意用，行为取消用）</p>
</li>
<li><p><code>builtin</code>：内置 OpenSSL 缓存，仅在一个工作进程中使用。缓存大小在会话中指定。如果未给出大小，则等于 20480 个会话。使用内置缓存可能会导致内存碎片</p>
</li>
<li><p><code>shared</code>：所有工作进程之间共享缓存，缓存的相关信息用 name 和 size 来指定，同 name 的缓存可用于多个虚拟服务器</p>
<p>name 是允许缓存的数据名，size 是允许缓存的数据大小，以字节为单位</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssl_session_cache</span> builtin:<span class="number">1000</span> shared:SSL:<span class="number">10m</span>;</span><br></pre></td></tr></table></figure>

<p>10m 的 m 是兆。</p>
<p><code>ssl_session_timeout</code> 指令用于开启 SSL 会话功能后，设置客户端能够反复使用储存在缓存中的会话参数时间，默认值超时时间是 5 秒</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_session_timeout &lt;time&gt;;</td>
<td>ssl_session_timeout 5m;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p><code>ssl_ciphers</code> 指令指出允许的密码，密码指定为 OpenSSL 支持的格式</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_ciphers &lt;ciphers&gt;;</td>
<td>ssl_ciphers HIGH:!aNULL:!MD5;</td>
<td>http、server</td>
</tr>
</tbody></table>
<p>可以直接在 Linux 系统上使用 <code>openssl ciphers</code> 查看 OpenSSl 支持的格式</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ciphers</span><br></pre></td></tr></table></figure>

<p><code>ssl_prefer_server_ciphers</code> 指令指定是否服务器密码优先客户端密码，默认关闭，建议开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>ssl_perfer_server_ciphers &lt;on | off&gt;;</td>
<td>ssl_perfer_server_ciphers off;</td>
<td>http、server</td>
</tr>
</tbody></table>
<h3 id="SSL证书生成"><a href="#SSL证书生成" class="headerlink" title="SSL证书生成"></a>SSL证书生成</h3><p><strong>方式一：使用阿里云/腾讯云等第三方服务进行购买免费版</strong></p>
<p>需要购买域名进行证书的绑定，否则证书无法使用。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.5p2qyl61ozc0.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.5l7iqyudol00.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6ci6w9wu24g0.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.4k9v2b9n6tm0.webp" alt="image"></p>
<p>接着在右边弹窗进行域名绑定，填完写域名和个人信息，进入到验证信息</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.11wx9z7jit3k.webp" alt="image"></p>
<p>点击验证，不成功则去自己的域名解析列表查看，如下，点击添加记录，进行配置，或者已经看到记录类型是 TXT，记录值和上图一样的，则说明成功。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6qcpqete8ic0.webp" alt="image"></p>
<p>提交审核后，点击下载</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.28m5753glfy8.webp" alt="image"></p>
<p>下载 Nginx 服务器的证书</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6kmq7nhonys0.webp" alt="image"></p>
<p>下载压缩包进行加压后，得到 .pem 证书和 .key 证书，把两个证书上传到 Linux，进行配置，往下看。</p>
<p><strong>方式二：使用 OpenSSL 生成证书</strong></p>
<p>这个方式适用于学习阶段，实际开发阶段使用方式一</p>
<ol>
<li>先要确认当前系统是否有安装 OpenSSL</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl version</span><br></pre></td></tr></table></figure>

<p>安装下面的命令进行生成（一步一步来）</p>
<ol start="2">
<li>创建 <code>/root/cerr</code> 目录并进入</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/cert</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /root/cert</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>指定加密算法和加密方式，生成 <code>server.key</code></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># genrsa 是加密算法，des3 是加密方式，-out 代表输入长度为 2048 的 server.key</span></span><br><span class="line">openssl genrsa -des3 -out server.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后它会让你注册 server.key 的密码</span></span><br><span class="line"><span class="comment"># 输入密码 ......</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>根据你注册的 server.key 密码，生成 server.csr 文件，生成后它会让你注册你的基本信息，因为是个人的，所以信息随便填写</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里注册你的基本信息，信息随便填写</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.2b4bgtawqb4.webp" alt="image"></p>
<ol start="5">
<li>备份 server.key</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp server.key server.key.org</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>重新生成 server.key 文件，并输入刚才注册的密码</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> server.key.org -out server.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会让你重新输入注册密码</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>生成 server.crt 文件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>最后使用 <code>ll</code> 查看目录下是否生成相应的文件：</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.3yl8ne2bkre0.webp" alt="image"></p>
<h3 id="SSL实例模板-通用"><a href="#SSL实例模板-通用" class="headerlink" title="SSL实例模板(通用)"></a>SSL实例模板(通用)</h3><p>Nginx 的置文件添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;		<span class="comment"># 开启 SSL 功能</span></span><br><span class="line">    <span class="attribute">server_name</span>  localhost;     <span class="comment"># 如果是购买的域名，这里加上该域名</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      /root/cert/server.cert; <span class="comment"># 生成的 cert 或者 pem 证书路径，根据需求修改</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /root/cert/server.key; <span class="comment"># 生成的 key 证书路径，根据需求修改</span></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>; </span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; <span class="comment"># 表示使用的加密套件的类型</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;  <span class="comment"># 表示使用的TLS协议的类型</span></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个模板就是 Nginx 解压目录的 conf 目录下的 nginx.conf 内容。</p>
<p><strong>建议</strong></p>
<p>配置 SSL 证书时候，不要修改原来的 server 模块（<code>listen 80</code> 模块），应该新建一个 server 模块。</p>
<p><strong>解决默认 http 问题。</strong></p>
<p>配置完 SSL 证书还远远不安全。如果直接输入 <code>www.frx.com</code>，会默认加上『 http:// 』 而不是『 https:// 』，如何修改为『 https:// 』呢，我们利用 Rewrite 功能</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> www.frx.com;   <span class="comment"># 如果是 www.frx.com 发送请求</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment"># ......</span></span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://www.frx.com<span class="variable">$1</span>;  <span class="comment"># 则改为 https 方式</span></span><br><span class="line">        <span class="comment"># ......</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反向代理系统调优"><a href="#反向代理系统调优" class="headerlink" title="反向代理系统调优"></a>反向代理系统调优</h2><p>反向代理值 Buffer 和 Cache。</p>
<p>Buffer 翻译过来是「缓冲」，Cache 翻译过来是「缓存」。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.6p7uoj5ab0k0.webp" alt="image"></p>
<p>客户端通过代理服务器向被代理服务器获取数据后，代理服务器在获取的数据存储在缓存「瓶子」里，客户端再次获取相同资源时，直接从缓存「瓶子」里获取数据，不需要向被代理服务器获取数据，减轻压力。</p>
<p>相同点:</p>
<ul>
<li>两种方式都是用来提供 IO 吞吐效率，都是用来提升 Nginx 代理的性能。</li>
</ul>
<p>不同点:</p>
<ul>
<li>缓冲主要用来解决不同设备之间数据传递速度不一致导致的性能低的问题，缓冲中的数据一旦此次操作完成后，就可以删除</li>
<li>缓存主要是备份，将被代理服务器的数据缓存一份到代理服务器，这样的话，客户端再次获取相同数据的时候，就只需要从代理服务器上获取，效率较高，缓存中的数据可以重复使用，只有满足特定条件才会删除</li>
</ul>
<h3 id="Proxy-Buffer-相关指令"><a href="#Proxy-Buffer-相关指令" class="headerlink" title="Proxy Buffer 相关指令"></a>Proxy Buffer 相关指令</h3><ul>
<li><p><code>proxy_buffering</code> 指令用来开启或者关闭代理服务器的缓冲区，默认开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_buffering &lt;on | off&gt;;</td>
<td>proxy_buffering on;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
<li><p><code>proxy_buffers</code> 指令用来指定单个连接从代理服务器读取响应的缓存区的个数和大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_buffers &lt;number&gt; &lt;size&gt;;</td>
<td>proxy_buffers 8 4k | 8K;(与系统平台有关)</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ul>
<li>number：缓冲区的个数</li>
<li>size：每个缓冲区的大小，缓冲区的总大小就是 number * size</li>
</ul>
</li>
<li><p><code>proxy_buffer_size</code> 指令用来设置从被代理服务器获取的第一部分响应数据的大小。保持与 proxy_buffers 中的 size 一致即可，当然也可以更小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_buffer_size &lt;size&gt;;</td>
<td>proxy_buffer_size 4k | 8k;(与系统平台有关)</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
<li><p><code>proxy_busy_buffers_size</code> 指令用来限制同时处于 BUSY 状态的缓冲总大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_busy_buffers_size &lt;size&gt;;</td>
<td>proxy_busy_buffers_size 8k | 16K;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
<li><p><code>proxy_temp_path</code> 指令用于当缓冲区存满后，仍未被 Nginx 服务器完全接受，响应数据就会被临时存放在磁盘文件上的该指令设置的文件路径下</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_temp_path &lt;path&gt;;</td>
<td>proxy_temp_path proxy_temp;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>注意 path 最多设置三层。</p>
</li>
<li><p><code>proxy_temp_file_write_size</code> 指令用来设置磁盘上缓冲文件的大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>proxy_temp_file_write_size &lt;size&gt;;</td>
<td>proxy_temp_file_write_size 8K | 16K;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="网站调优模板-通用"><a href="#网站调优模板-通用" class="headerlink" title="网站调优模板(通用)"></a>网站调优模板(通用)</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_buffering</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">proxy_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line"><span class="attribute">proxy_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line"><span class="attribute">proxy_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line"><span class="attribute">proxy_temp_file_write_size</span> <span class="number">128k</span>;</span><br></pre></td></tr></table></figure>

<h2 id="反向代理问题"><a href="#反向代理问题" class="headerlink" title="反向代理问题"></a>反向代理问题</h2><p>反向代理有一个严重的问题，那就是反向代理的网站需要的 css、js、png 等静态文件默认是从 Nginx 里获取，显然一个你的服务器的代理了如淘宝、京东等网站，那么淘宝、京东等网站的静态文件是从你的服务器里获取，但是服务器根本没有，那么我们如何让代理的网站以及网站需要的 css、js、png 等静态文件一同获取呢，添加如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*</span> &#123;							<span class="comment"># 如果不是代理网站的根路径，请自行修改</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8081;   <span class="comment"># 代理的网站地址</span></span><br><span class="line">        <span class="comment"># 将网站的静态文件也代理过来</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/11/NginxStatic_resource_access/">Nginx 静态资源访问</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-静态资源访问"><a href="#Nginx-静态资源访问" class="headerlink" title="Nginx 静态资源访问"></a>Nginx 静态资源访问</h1><p><strong>引言</strong></p>
<p>如何访问 Nginx 的静态资源？这其中涉及到了 Nginx 的核心功能 Rewrite 重写技术，本内容将讲解处理访问静态资源的相关知识。</p>
<hr>
<h2 id="Nginx的跨域问题"><a href="#Nginx的跨域问题" class="headerlink" title="Nginx的跨域问题"></a>Nginx的跨域问题</h2><p>跨域问题，我们主要从以下方面进行解决：</p>
<ul>
<li>什么情况下会出现跨域问题</li>
<li>实例演示跨域问题</li>
<li>具体的解决方案是什么</li>
</ul>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>浏览器的同源策略：是一种约定，是浏览器最核心也是最基本的安全功能，如果浏览器少了同源策略，则浏览器的正常功能可能都会受到影响。</p>
<p>同源：协议、域名(IP)、端口相同即为同源</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.131/user/1</span><br><span class="line">https://192.168.200.131/user/1</span><br><span class="line"><span class="comment"># 不满足同源</span></span><br><span class="line"></span><br><span class="line">http://192.168.200.131/user/1</span><br><span class="line">http://192.168.200.132/user/1</span><br><span class="line"><span class="comment"># 不满足同源</span></span><br><span class="line"></span><br><span class="line">http://192.168.200.131/user/1</span><br><span class="line">http://192.168.200.131:8080/user/1</span><br><span class="line"><span class="comment"># 不满足同源</span></span><br><span class="line"></span><br><span class="line">http://www.nginx.com/user/1</span><br><span class="line">http://www.nginx.org/user/1</span><br><span class="line"><span class="comment"># 不满足同源</span></span><br><span class="line"></span><br><span class="line">http://192.168.200.131/user/1</span><br><span class="line">http://192.168.200.131:8080/user/1</span><br><span class="line"><span class="comment"># 不满足同源</span></span><br><span class="line"></span><br><span class="line">http://www.nginx.org:80/user/1</span><br><span class="line">http://www.nginx.org/user/1</span><br><span class="line"><span class="comment"># 满足同源</span></span><br></pre></td></tr></table></figure>

<h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>简单描述下：</p>
<p>有两台服务器分别为 A、B，如果从服务器 A 的页面发送异步请求到服务器 B 获取数据，如果服务器 A 和服务器 B 不满足同源策略，则就会出现跨域问题。</p>
<h3 id="跨域案例"><a href="#跨域案例" class="headerlink" title="跨域案例"></a>跨域案例</h3><p>出现跨域问题会有什么效果？接下来通过一个需求来给大家演示下：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.vlv6telsbb4.webp" alt="image"></p>
<ol>
<li>Nginx 的 html 目录下新建一个 a.html</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/nginx/html/a.htm</span><br></pre></td></tr></table></figure>

<p>添加如下内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>跨域问题演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">            $(function()&#123;</span><br><span class="line">                $("#btn").click(function()&#123;</span><br><span class="line">                        $.get('http://192.168.200.133:8080/getUser',function(data)&#123;</span><br><span class="line">                                alert(JSON.stringify(data));</span><br><span class="line">                        &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"获取数据"</span> <span class="attr">id</span>=<span class="string">"btn"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 nginx.conf 配置如下内容</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> /getUser&#123;</span><br><span class="line">        <span class="attribute">default_type</span> application/json;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&#123;"id":1,"name":"TOM","age":18&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> 	<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /&#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过浏览器测试访问</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.4md37urjzug0.webp" alt="image"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用 <code>add_header</code> 指令，该指令可以用来添加一些头信息。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>add_header &lt;name&gt; &lt;value&gt; ……</td>
<td>—</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>此处用来解决跨域问题，需要添加两个头信息，分别是</p>
<ul>
<li><code>Access-Control-Allow-Origin</code></li>
<li><code>Access-Control-Allow-Methods</code></li>
</ul>
<p><code>Access-Control-Allow-Origin</code>：直译过来是允许跨域访问的源地址信息，可以配置多个(多个用逗号分隔)，也可以使用 <code>*</code> 代表所有源。</p>
<p><code>Access-Control-Allow-Methods</code>：直译过来是允许跨域访问的请求方式，值可以为 GET、POST、PUT、DELETE ……，可以全部设置，也可以根据需要设置，多个用逗号分隔。</p>
<p>具体配置方式：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /getUser &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Methods GET,POST,PUT,DELETE;</span><br><span class="line">    <span class="attribute">default_type</span> application/json;   <span class="comment"># return 的格式是 json</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&#123;"id":1,"name":"TOM","age":18&#125;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态资源防盗链"><a href="#静态资源防盗链" class="headerlink" title="静态资源防盗链"></a>静态资源防盗链</h2><h3 id="什么是资源盗链"><a href="#什么是资源盗链" class="headerlink" title="什么是资源盗链"></a>什么是资源盗链</h3><p>资源盗链指的是此内容不在自己服务器上，而是通过技术手段，绕过别人的限制将别人的内容放到自己页面上最终展示给用户。以此来盗取大网站的空间和流量。简而言之就是用别人的东西成就自己的网站。</p>
<p>提供两种图片进行演示：</p>
<ul>
<li>京东：<code>https://img14.360buyimg.com/n7/jfs/t1/101062/37/2153/254169/5dcbd410E6d10ba22/4ddbd212be225fcd.jpg</code></li>
<li>百度：<code>https://pics7.baidu.com/feed/cf1b9d16fdfaaf516f7e2011a7cda1e8f11f7a1a.jpeg?token=551979a23a0995e5e5279b8fa1a48b34&amp;s=BD385394D2E963072FD48543030030BB</code></li>
</ul>
<p>我们在 html 目录下准备一个页面 a.html，在页面上利用 img 标签引入这两个图片:</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.614vk7i0kx80.webp" alt="image"></p>
<p>访问：<code>http://192.168.200.133/a.html</code> 来查看效果</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.2m5u48xesf60.webp" alt="image"></p>
<p>从上面的效果，可以看出来，下面的图片地址添加了防止盗链的功能，京东这边我们可以直接使用其图片。</p>
<h3 id="防盗链实现原理"><a href="#防盗链实现原理" class="headerlink" title="防盗链实现原理"></a>防盗链实现原理</h3><p>了解防盗链的原理之前，我们得先学习一个 HTTP 的头信息 Referer，当浏览器向 Web 服务器发送请求的时候，一般都会带上 Referer，来告诉浏览器该网页是从哪个页面链接过来的。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.64vdmkvdywk0.webp" alt="image"></p>
<p>后台服务器可以根据获取到的这个 Referer 信息来判断是否为自己信任的网站地址，如果是则放行继续访问，如果不是则可以返回 403（服务端拒绝访问）的状态信息。</p>
<h3 id="防盗链实现实例"><a href="#防盗链实现实例" class="headerlink" title="防盗链实现实例"></a>防盗链实现实例</h3><p>在本地模拟上述的服务器效果图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.4hr6e3mrf440.webp" alt="image"></p>
<p>Nginx 防盗链的具体实现：</p>
<p>valid_referers 指令：Nginx 会通过查看 Referer 自动和 valid_referers 的内容进行匹配，如果匹配到了就将 <code>$invalid_referer</code> 变量置 0，如果没有匹配到，则将 <code>$invalid_referer</code> 变量置为 1，匹配的过程中不区分大小写。</p>
<p>所以我们可以在配置文件判断 <code>$invalid_referer</code> 是否等于 1（true），即没有匹配到 ，等于则返回 403。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>valid_referers &lt;none | blocked | server_names | string&gt; ……</td>
<td>—</td>
<td>server、location</td>
</tr>
</tbody></table>
<ul>
<li>none：如果 Header 中的 Referer 为空，允许访问</li>
<li>blocked：在 Header 中的 Referer 不为空，但是该值被防火墙或代理进行伪装过，如不带『 http:// 』 、『 https:// 』等协议头的资源才允许访问。</li>
<li>server_names：指定具体的域名或者 IP</li>
<li>string：可以支持正则表达式和 <code>*</code> 的字符串。如果是正则表达式，需要以 <code>~</code> 开头表示</li>
</ul>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ *\.(png|jpg|gif)</span>&#123;</span><br><span class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> www.baidu.com <span class="number">192.168.91.200</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># valid_referers none blocked *.example.com example.*  www.example.org  ~\.google\.;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>)&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上方代码如果没有匹配上 <code>www.baidu.com</code> 和 <code>192.168.91.200</code>，则 <code>$invalid_referer</code> 为 1（true），返回 403，代表不允许获取资源。</p>
<p>Nginx 配置文件支持 if 判断，但是 if 后面必须有空格。</p>
<p><strong>问题：如果图片有很多，该如何批量进行防盗链？可以针对目录进行防盗链。</strong></p>
<h3 id="针对目录防盗链"><a href="#针对目录防盗链" class="headerlink" title="针对目录防盗链"></a>针对目录防盗链</h3><p>假设 html 目录下有一个 images 目录，里面专门放防盗链的图片。</p>
<p>配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> www.baidu.com <span class="number">192.168.199.27</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># valid_referers none blocked *.example.com example.*  www.example.org  ~\.google\.;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>)&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需将 location 的地址改成一个目录，这样我们可以对一个目录下的所有资源进行防盗链操作。</p>
<p><strong>问题：Referer 的限制比较粗，比如浏览器发送请求时恶意加一个 Referer，上面的方式是无法进行限制的。那么这个问题改如何解决？</strong></p>
<p>此时我们需要用到 Nginx 的第三方模块 <code>ngx_http_accesskey_module</code>，第三方模块如何实现盗链，如何在 Nginx 中使用第三方模块的功能，在后面有讲解。</p>
<h2 id="Rewrite功能配置"><a href="#Rewrite功能配置" class="headerlink" title="Rewrite功能配置"></a>Rewrite功能配置</h2><p>Rewrite 是 Nginx 服务器提供的一个重要基本功能，是 Web 服务器产品中几乎必备的功能。主要的作用是用来实现 URL 的重写。</p>
<p>*<em>warning *</em></p>
<p>Nginx 服务器的 Rewrite 功能的实现依赖于 PCRE 的支持，因此在编译安装 Nginx 服务器之前，需要安装 PCRE 库。Nginx 使用的是<code>ngx_http_rewrite_module</code> 模块来解析和处理 Rewrite 功能的相关配置。</p>
<h3 id="地址重写与地址转发"><a href="#地址重写与地址转发" class="headerlink" title="地址重写与地址转发"></a>地址重写与地址转发</h3><p>重写和转发的区别:</p>
<ul>
<li>地址重写浏览器地址会发生变化而地址转发则不变</li>
<li>一次地址重写会产生两次请求而一次地址转发只会产生一次请求</li>
<li>地址重写到的页面必须是一个完整的路径而地址转发则不需要</li>
<li>地址重写因为是两次请求，所以 request 范围内属性不能传递给新页面，而地址转发因为是一次请求所以可以传递值</li>
<li>地址转发速度快于地址重写</li>
</ul>
<h3 id="set指令"><a href="#set指令" class="headerlink" title="set指令"></a>set指令</h3><p>该指令用来设置一个新的变量。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>set &lt;$key&gt; &lt;value&gt;;</td>
<td>—</td>
<td>server、location、if</td>
</tr>
</tbody></table>
<ul>
<li>variable：变量的名称，该变量名称要用 <code>$</code> 作为变量的第一个字符，且不能与 Nginx 服务器内置的全局变量同名。</li>
<li>value：变量的值，可以是字符串、其他变量或者变量的组合等。</li>
</ul>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> /server &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$name</span> TOM;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$age</span> <span class="number">18</span>;</span><br><span class="line">        <span class="attribute">default_type</span> text/plain;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$name</span>=<span class="variable">$age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>https://192.168.200.133:8081:server</code>，返回结果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.6t618fip2fo0.webp" alt="image"></p>
<h3 id="Rewrite常用全局变量"><a href="#Rewrite常用全局变量" class="headerlink" title="Rewrite常用全局变量"></a>Rewrite常用全局变量</h3><table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$args</td>
<td>变量中存放了请求 URL 中的请求指令。比如 <code>http://192.168.200.133:8080?arg1=value1&amp;args2=value2</code> 中的『 arg1=value1&amp;arg2=value2 』，功能和 $query_string 一样</td>
</tr>
<tr>
<td>$http_user_agent</td>
<td>变量存储的是用户访问服务的代理信息（如果通过浏览器访问，记录的是浏览器的相关版本信息）</td>
</tr>
<tr>
<td>$host</td>
<td>变量存储的是访问服务器的 server_name 值</td>
</tr>
<tr>
<td>$document_uri</td>
<td>变量存储的是当前访问地址的URI。比如 <code>http://192.168.200.133/server?id=10&amp;name=zhangsan</code>中的『 /server 』，功能和 $uri 一样</td>
</tr>
<tr>
<td>$document_root</td>
<td>变量存储的是当前请求对应 location 的 root 值，如果未设置，默认指向 Nginx 自带 html 目录所在位置</td>
</tr>
<tr>
<td>$content_length</td>
<td>变量存储的是请求头中的 Content-Length 的值</td>
</tr>
<tr>
<td>$content_type</td>
<td>变量存储的是请求头中的 Content-Type 的值</td>
</tr>
<tr>
<td>$http_cookie</td>
<td>变量存储的是客户端的 cookie 信息，可以通过 <code>add_header Set-Cookie &#39;cookieName=cookieValue&#39;</code> 来添加 cookie 数据</td>
</tr>
<tr>
<td>$limit_rate</td>
<td>变量中存储的是 Nginx 服务器对网络连接速率的限制，也就是 Nginx 配置中对 limit_rate 指令设置的值，默认是 0，不限制。</td>
</tr>
<tr>
<td>$remote_addr</td>
<td>变量中存储的是客户端的 IP 地址</td>
</tr>
<tr>
<td>$remote_port</td>
<td>变量中存储了客户端与服务端建立连接的端口号</td>
</tr>
<tr>
<td>$remote_user</td>
<td>变量中存储了客户端的用户名，需要有认证模块才能获取</td>
</tr>
<tr>
<td>$scheme</td>
<td>变量中存储了访问协议</td>
</tr>
<tr>
<td>$server_addr</td>
<td>变量中存储了服务端的地址</td>
</tr>
<tr>
<td>$server_name</td>
<td>变量中存储了客户端请求到达的服务器的名称</td>
</tr>
<tr>
<td>$server_port</td>
<td>变量中存储了客户端请求到达服务器的端口号</td>
</tr>
<tr>
<td>$server_protocol</td>
<td>变量中存储了客户端请求协议的版本，比如 『 HTTP/1.1 』</td>
</tr>
<tr>
<td>$request_body_file</td>
<td>变量中存储了发给后端服务器的本地文件资源的名称</td>
</tr>
<tr>
<td>$request_method</td>
<td>变量中存储了客户端的请求方式，比如『 GET 』,『 POST 』等</td>
</tr>
<tr>
<td>$request_filename</td>
<td>变量中存储了当前请求的资源文件的路径名</td>
</tr>
<tr>
<td>$request_uri</td>
<td>变量中存储了当前请求的 URI，并且携带请求参数，比如 <code>http://192.168.200.133/server?id=10&amp;name=zhangsan</code> 中的 『 /server?id=10&amp;name=zhangsan 』</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>例如</strong></p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">location</span> /server &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/local/nginx/abc;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$name</span> TOM;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$age</span> <span class="number">18</span>;</span><br><span class="line">        <span class="attribute">default_type</span> text/plain;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$name</span>=<span class="variable">$age</span>=<span class="variable">$args</span>=<span class="variable">$http_user_agent</span>=<span class="variable">$host</span>=<span class="variable">$document_root</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问：<code>http://192.168.200.133:8081/server?username=JERRY&amp;gender=1</code></p>
<p>效果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.6s6hlgez73g0.webp" alt="image"></p>
<blockquote>
<p><strong>可以把访问的信息记录在日志中</strong></p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="comment"># ......</span></span><br><span class="line">	<span class="attribute">log_format</span> main <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$request</span> - <span class="variable">$status</span> - <span class="variable">$request_uri</span> - <span class="variable">$http_user_agent</span>'</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="attribute">location</span> /server &#123;</span><br><span class="line">        	<span class="attribute">access_log</span> logs/access.log main;</span><br><span class="line">            <span class="attribute">root</span> /usr/local/nginx/abc;</span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$name</span> TOM;</span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$age</span> <span class="number">18</span>;</span><br><span class="line">            <span class="attribute">default_type</span> text/plain;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$name</span>=<span class="variable">$age</span>=<span class="variable">$args</span>=<span class="variable">$http_user_agent</span>=<span class="variable">$host</span>=<span class="variable">$document_root</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问：<code>http://192.168.200.133:8081/server?username=JERRY&amp;gender=1</code></p>
<p>然后查看日志，效果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220801/image.23y9h76w29b4.webp" alt="image"></p>
<h3 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h3><p>该指令用来支持条件判断，并根据条件判断结果选择不同的 Nginx 配置。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>if (condition) { … }</td>
<td>—</td>
<td>server、location</td>
</tr>
</tbody></table>
<p>if 和括号之间要有空格，condition 为判定条件，可以支持以下写法：</p>
<ul>
<li>变量名。如果变量名对应的值为空或者是 0，if 都判断为 false，其他条件为 true。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$param</span>)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用『 = 』和『 != 』比较变量和字符串是否相等，满足条件为 true，不满足为 false</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$request_method</span> = POST)&#123;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">405</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：POST 和 Java 不太一样的地方是字符串不需要添加引号。</p>
<ul>
<li>使用正则表达式对变量进行匹配，匹配成功返回 true，否则返回 false。变量与正则表达式之间使用『 ~ 』，『 <del>* 』，『 !</del> 』，『 !~* 』来连接。<ul>
<li>『 ~ 』代表匹配正则表达式过程中区分大小写，进行模糊匹配</li>
<li>『 ~* 』代表匹配正则表达式过程中不区分大小写，进行模糊匹配</li>
<li>『 !~ 』和『 !~* 』刚好和上面取相反值，如果匹配上返回 false，匹配不上返回 true，进行模糊匹配</li>
</ul>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$http_user_agent</span> <span class="regexp">~ MSIE)</span>&#123;</span><br><span class="line">	<span class="comment"># $http_user_agent 的值中是否包含 MSIE 字符串，如果包含返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断请求的文件是否存在使用『 -f 』和『 !-f 』<ul>
<li>当使用『 -f 』时，如果请求的文件存在返回 true，不存在返回 false。</li>
<li>当使用『 !-f 』时，如果请求文件不存在，但该文件所在目录存在返回 true，文件和目录都不存在返回 false，如果文件存在返回 false。</li>
</ul>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (-f <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">	<span class="comment"># 判断请求的文件是否存在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">if</span> (!-f <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">	<span class="comment"># 判断请求的文件是否不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：用户访问的页面不存在，则返回一个友好的提示</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span> html;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;</span><br><span class="line">    <span class="comment"># 判断请求的文件是否不存在</span></span><br><span class="line">    <span class="attribute">if</span> (!-f <span class="variable">$request_filename</span>)&#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&lt;h1&gt;不好意思，文件资源找不到！&lt;/h1&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>判断请求的目录是否存在使用『 -d 』和『 !-d 』</p>
<p>当使用『 -d 』时，如果请求的目录存在，返回 true，如果目录不存在则返回 false。</p>
<p>当使用『 !-d 』时，如果请求的目录不存在但该目录的上级目录存在则返回 true，该目录和它上级目录都不存在则返回 false，如果请求目录存在也返回false。</p>
</li>
</ul>
<h3 id="break指令"><a href="#break指令" class="headerlink" title="break指令"></a>break指令</h3><p>该指令用于中断当前相同作用域中的其他 Nginx 配置。与该指令处于同一作用域的 Nginx 配置中，位于它前面的指令配置生效，位于后面的指令配置无效。并且break还有另外一个功能就是终止当前的匹配并把当前的URI在本location进行重定向访问处理。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>break;</td>
<td>—</td>
<td>server、location、if</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /testbreak &#123;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$username</span> TOM;</span><br><span class="line">	<span class="attribute">if</span> (<span class="variable">$args</span>)&#123;</span><br><span class="line">		<span class="attribute">set</span> <span class="variable">$username</span> JERRY;</span><br><span class="line">		break;</span><br><span class="line">		<span class="attribute">set</span> <span class="variable">$username</span> ROSE;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="attribute">add_header</span> username <span class="variable">$username</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$username</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不带参数访问：<code>http://192.168.200.133:8081/testbreak</code></p>
<p>效果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.2ok6tnbtnx20.webp" alt="image"></p>
<p>带参数访问：<code>http://192.168.200.133:8081/testbreak/1</code></p>
<p>效果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.1f6a03pxv4ow.webp" alt="image"></p>
<h3 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h3><p>该指令用于完成对请求的处理，直接向客户端返回响应状态代码。在 return 后的所有 Nginx 配置都是无效的。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>return &lt;code&gt; [text];<br> return &lt;code&gt; &lt;URL&gt;; <br>return &lt;URL&gt;;</td>
<td>—</td>
<td>server、location、if</td>
</tr>
</tbody></table>
<ul>
<li>code：返回给客户端的 HTTP 状态代理。可以返回的状态代码为 0 ~ 999 的任意 HTTP 状态代理</li>
<li>text：返回给客户端的响应体内容，支持变量的使用和 JSON 字符串</li>
<li>URL：跳转给客户端的 URL 地址。</li>
</ul>
<p>例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">"欢迎使用 Nginx"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /baidu &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">302</span> https://www.baidu.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时访问 Nginx，就会在页面看到这句话：欢迎使用 Nginx。</p>
<p>如果访问 <code>/baidu</code>，则跳转到 <code>https://www.baidu.com</code>。</p>
<h3 id="rewrite指令"><a href="#rewrite指令" class="headerlink" title="rewrite指令"></a>rewrite指令</h3><p>该指令通过正则表达式的使用来改变 URI。可以同时存在一个或者多个指令，按照顺序依次对 URL 进行匹配和处理。</p>
<p>URL 和 URI 的区别：</p>
<ul>
<li>URI：统一资源标识符</li>
<li>URL：统一资源定位符</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>rewrite regex replacement [flag];</td>
<td>—</td>
<td>server、location、if</td>
</tr>
</tbody></table>
<ul>
<li><p>regex：用来匹配 URI 的正则表达式</p>
</li>
<li><p>replacement：匹配成功后，用于替换 URI 中被截取内容的字符串。如果该字符串是以 『 http:// 』或者『 https:// 』开头的，则不会继续向下对URI 进行其他处理，而是直接返回重写后的 URI 给客户端。</p>
<p>例如：（括号的值会作为 $1 的值）^ 代表匹配输入字符串的起始位置</p>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"><span class="attribute">location</span> /rewrite &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/url\w*$</span> https://www.baidu.com;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(test)\w*$</span> /<span class="variable">$1</span>;   <span class="comment"># 如果是 /rewrite/testxxx，则重写 url 为 test</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(demo)\w*$</span> /<span class="variable">$1</span>;    <span class="comment"># 如果是 /rewrite/demoxxx，则重写 url 为 demo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /test &#123;   <span class="comment"># 重写后的 url 如果为 test，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> test_sucess;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /demo &#123;   <span class="comment"># 重写后的 url 如果为 demo，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> demo_sucess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>http://192.168.200.113/8081/rewrite/urlxxx</code>，跳转到 <code>https://www.baidu.com</code>。</p>
<p>访问 <code>http://192.168.200.113/8081/rewrite/testxxx</code>，返回 test_sucess。</p>
<p>访问 <code>http://192.168.200.113/8081/rewrite/demoxxx</code>，返回 demo_sucess。</p>
<p>flag：用来设置 Rewrite 对 URI 的处理行为，可选值有如下：</p>
<ul>
<li><code>last</code>：终止继续在本 location 块中处理接收到的后续 URI，并将此处重写的 URl 作为一个新的 URI，使用各 location 块进行处理。该标志将重写后的 URI 重写在 server 块中执行，为重写后的 URI 提供了转入到其他 location 块的机会。<strong>重写地址后访问其他的 location 块，浏览器地址栏 URL 地址不变</strong></li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"><span class="attribute">location</span> /rewrite &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(test)\w*$</span> /<span class="variable">$1</span> <span class="literal">last</span>;   <span class="comment"># 如果是 /rewrite/testxxx，则重写 url 为 test</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(demo)\w*$</span> <span class="variable">$1</span> <span class="literal">last</span>;    <span class="comment"># 如果是 /rewrite/demoxxx，则重写 url 为 demo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /test &#123;   <span class="comment"># 重写后的 url 如果为 test，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> test_sucess;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /demo &#123;   <span class="comment"># 重写后的 url 如果为 demo，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> demo_sucess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>http://192.168.200.113/8081/rewrite/testxxx</code>，返回 test_sucess。</p>
<p>访问 <code>http://192.168.200.113/8081/rewrite/demoxxx</code>，返回 demo_sucess。</p>
<p>单次访问不明显，多次访问，last 只处理第一个。</p>
<ul>
<li><code>break</code>：将此处重写的 URl 作为一个新的 URI，在本块中继续进行处理。该标志将重写后的地址在当前的 location 块中执行，不会将新的 URI 转向其他的 location 块。<strong>仅仅重写地址，不会触发其他 location 块，浏览器地址栏 URL 地址不变</strong></li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"><span class="attribute">location</span> /rewrite &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(test)\w*$</span> /<span class="variable">$1</span> <span class="literal">break</span>;   <span class="comment"># 如果是 /rewrite/testxxx，则重写 url 为 test</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(demo)\w*$</span> <span class="variable">$1</span> <span class="literal">break</span>;    <span class="comment"># 如果是 /rewrite/demoxxx，则重写 url 为 demo</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># /test 和 /demo 就在当前块进行处理，所以会在当前的 location 块找到如下 html 页面：</span></span><br><span class="line">    <span class="comment"># /usr/local/nginx/html/test/index.html</span></span><br><span class="line">    <span class="comment"># /usr/local/nginx/html/demo/index.html</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /test &#123;   <span class="comment"># 重写后的 url 如果为 test，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> test_sucess;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /demo &#123;   <span class="comment"># 重写后的 url 如果为 demo，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> demo_sucess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 break 指令类似。假设访问的是 /test，则将 /test 放在当前的 location 块进行处理，哪怕第二个 location 块就是处理 /test 的，它也不会去找第二个 location 块，只在当前块进行处理。所以他会请求 <code>/usr/local/nginx/html/test/index.html</code>。</p>
<ul>
<li><code>redirect</code>：将重写后的 URI 返回给客户端，状态码为 302，指明是临时重定向 URL，主要用在 replacement 变量不是以『 http:// 』或者『 https:// 』开头的情况</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"><span class="attribute">location</span> /rewrite &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(test)\w*$</span> /<span class="variable">$1</span> <span class="literal">redirect</span>;   <span class="comment"># 如果是 /rewrite/testxxx，则重写 url 为 test</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(demo)\w*$</span> <span class="variable">$1</span> <span class="literal">redirect</span>;    <span class="comment"># 如果是 /rewrite/demoxxx，则重写 url 为 demo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /test &#123;   <span class="comment"># 重写后的 url 如果为 test，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> test_sucess;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /demo &#123;   <span class="comment"># 重写后的 url 如果为 demo，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> demo_sucess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点是重定向，就是<strong>浏览的地址栏会发送改变</strong>。如发送请求 <code>/testxxx</code>，它会重定向到 <code>/test</code>，触发第二个 location 块，浏览的地址栏也会由 <code>/testxxx</code> 变成 <code>/test</code>。</p>
<ul>
<li><code>permanent</code>：将重写后的 URI 返回给客户端，状态码为 301，指明是永久重定向 URL，主要用在 replacement 变量不是以『 http:// 』或者『 https:// 』开头的情况</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"><span class="attribute">location</span> /rewrite &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(test)\w*$</span> /<span class="variable">$1</span> <span class="literal">permanent</span>;   <span class="comment"># 如果是 /rewrite/testxxx，则重写 url 为 test</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/rewrite/(demo)\w*$</span> <span class="variable">$1</span> <span class="literal">permanent</span>;    <span class="comment"># 如果是 /rewrite/demoxxx，则重写 url 为 demo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /test &#123;   <span class="comment"># 重写后的 url 如果为 test，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> test_sucess;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /demo &#123;   <span class="comment"># 重写后的 url 如果为 demo，触发 location</span></span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> demo_sucess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 <code>redirect</code> 的区别就是状态码为 301，并且是永久重定向。</p>
<h3 id="flag-总结"><a href="#flag-总结" class="headerlink" title="flag 总结"></a>flag 总结</h3><table>
<thead>
<tr>
<th>标记符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>last</td>
<td>本条规则匹配完成后继续向下匹配新的 location URI 规则</td>
</tr>
<tr>
<td>break</td>
<td>本条规则匹配完成后终止，不在匹配任何规则</td>
</tr>
<tr>
<td>redirect</td>
<td>返回 302 临时重定向</td>
</tr>
<tr>
<td>permanent</td>
<td>返回 301 永久重定向</td>
</tr>
</tbody></table>
<ul>
<li>break 与 last 都停止处理后续重写规则，只不过 last 会重新发起新的请求并使用新的请求路由匹配location，但 break 不会。所以当请求 break 时，如匹配成功，则请求成功，返回 200；如果匹配失败，则返回 404</li>
<li>服务器配置好 redirect 和 permanent 之后，打开浏览器分别访问这两个请求地址，然后停止 Nginx 服务。这时再访问 redirect 请求会直接报出无法连接的错误。但是 permanent 请求是永久重定向，浏览器会忽略原始地址直接访问永久重定向之后的地址，所以请求仍然成功。（这个验证不能禁用浏览器的缓存，否则即使是 permanent 重定向，浏览器仍然会向原始地址发出请求验证之前的永久重定向是否有效）</li>
<li>对于搜索引擎来说，搜索引擎在抓取到 301 永久重定向请求响应内容的同时也会将原始的网址替换为重定向之后的网址，而对于 302 临时重定向请求则仍然会使用原始的网址并且可能会被搜索引擎认为有作弊的嫌疑。所以对于线上正式环境来讲，尽量避免使用 302 跳转</li>
<li>如果 replacement 以 「 http:// 」或「 https:// 」或「 $scheme 」开始，处理过程将终止，并将这个重定向直接返回给客户端</li>
</ul>
<h3 id="rewrite-log指令"><a href="#rewrite-log指令" class="headerlink" title="rewrite_log指令"></a>rewrite_log指令</h3><p>该指令配置是否开启 URL 重写日志的输出功能，默认关闭。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>rewrite_log &lt;on | off&gt;;</td>
<td>rewrite_log off;</td>
<td>http、server、location、if</td>
</tr>
</tbody></table>
<p>开启后，URL 重写的相关日志将以 notice 级别输出到 error_log 指令配置的日志文件汇总。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /rewrite_log &#123;</span><br><span class="line">    <span class="attribute">rewrite_log</span> <span class="literal">on</span>;    <span class="comment"># 开启重写日志</span></span><br><span class="line">	<span class="attribute">error_log</span> logs /error.log <span class="literal">notice</span>;   <span class="comment"># 切换为 notice 模式，因为只支持这个模式</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'开启了重写日志'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rewrite的案例"><a href="#Rewrite的案例" class="headerlink" title="Rewrite的案例"></a>Rewrite的案例</h2><h3 id="域名跳转"><a href="#域名跳转" class="headerlink" title="域名跳转"></a>域名跳转</h3><p>问题分析</p>
<p>先来看一个效果，如果我们想访问京东网站，大家都知道我们可以输入 <code>www.jd.com</code>，但是同样的我们也可以输入 <code>www.360buy.com</code> 同样也都能访问到京东网站。这个其实是因为京东刚开始的时候域名就是 <code>www.360buy.com</code>，后面由于各种原因把自己的域名换成了 <code>www.jd.com</code>，虽然说域名改变了，但是对于以前只记住了 <code>www.360buy.com</code> 的用户来说，我们如何把这部分用户也迁移到我们新域名的访问上来，针对于这个问题，我们就可以使用 Nginx 中 Rewrite 的域名跳转来解决。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>准备两个域名 <a href="http://www.360buy.com" target="_blank" rel="noopener">www.360buy.com</a> | <a href="http://www.jd.com" target="_blank" rel="noopener">www.jd.com</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>

<p>添加内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.133 www.360buy.com</span><br><span class="line">192.168.200.133 www.jd.com</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>/usr/local/nginx/html/test</code> 目录下创建一个访问页面 frx.html</li>
</ul>
<p>添加内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎来到我的网站<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过 Nginx 实现当访问 <code>www.frx.com</code> 访问到 frx.html 页面</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.frx.com;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">root</span> /usr/local/nginx/html/;</span><br><span class="line">		<span class="attribute">index</span> frx.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Rewrite 完成将 <code>www.360buy.com</code> 的请求跳转到 <code>www.jd.com</code></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.360buy.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^/</span> http://www.jd.com <span class="literal">permanent</span>;   <span class="comment"># 永久重定向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题描述：如何在域名跳转的过程中携带请求的 URI？</strong></p>
<p>比如 <code>www.360buy.com?part=显示器</code> 变成 <code>www.jd.com?part=显示器</code></p>
<ul>
<li>修改配置信息</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.itheima.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://www.hm.com<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>括号里是 <code>www.itheima.com</code> 后面出现 0 次或 多次不以 \n（换行）结尾的值，该值赋给 $1。</p>
<p><strong>问题描述：我们除了上述说的只有 <a href="http://www.jd.com、www.360buy.com，其实还有我们也可以通过" target="_blank" rel="noopener">www.jd.com、www.360buy.com，其实还有我们也可以通过</a> <a href="http://www.jingdong.com" target="_blank" rel="noopener">www.jingdong.com</a> 来访问，那么如何通过 Rewrite 来实现多个域名的跳转?</strong></p>
<ul>
<li>添加域名</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开 hosts 文件</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加域名</span></span><br><span class="line">192.168.200.133 www.jingdong.com</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置信息</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.360buy.com www.jingdong.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://www.jd.com<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个 server_name 用空格隔开。</p>
<h3 id="域名镜像"><a href="#域名镜像" class="headerlink" title="域名镜像"></a>域名镜像</h3><p>上述案例中，将 <code>www.360buy.com</code> 和 <code>www.jingdong.com</code> 都能跳转到 <code>www.jd.com</code>，那么 <code>www.jd.com</code> 我们就可以把它起名叫主域名，其他两个就是我们所说的镜像域名，当然如果我们不想把整个网站做镜像，只想为其中某一个子目录下的资源做镜像，比如用户可以跳到首页 Web下，而管理员跳转到后台 Web，我们可以在 location 块中配置 Rewrite 功能。</p>
<p>比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> rewrite.myweb.com;</span><br><span class="line">	<span class="attribute">location</span><span class="regexp"> ^~</span> /user &#123;</span><br><span class="line">		<span class="attribute">rewrite</span><span class="regexp"> ^/user(.*)</span> http://www.myweb.com/index<span class="variable">$1</span> <span class="literal">last</span>;  <span class="comment"># 用户跳到首页</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="attribute">location</span><span class="regexp"> ^~</span> /manage &#123;</span><br><span class="line">		<span class="attribute">rewrite</span><span class="regexp"> ^/manage(.*)</span> http://www.myweb.com/manage<span class="variable">$1</span> <span class="literal">last</span>;  <span class="comment"># 管理员跳到后台</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="独立域名"><a href="#独立域名" class="headerlink" title="独立域名"></a>独立域名</h3><p>一个完整的项目包含多个模块，比如购物网站有商品商品搜索模块、商品详情模块已经购物车模块等，那么我们如何为每一个模块设置独立的域名。</p>
<p>需求：</p>
<ul>
<li><code>http://search.product.com</code>：访问商品搜索模块</li>
<li><code>http://item.product.com</code>：访问商品详情模块</li>
<li><code>http://cart.product.com</code>：访问商品购物车模块</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> search.product.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://www.shop.com/search<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">81</span>;</span><br><span class="line">	<span class="attribute">server_name</span> item.product.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://www.shop.com/item<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">82</span>;</span><br><span class="line">	<span class="attribute">server_name</span> cart.product.com;</span><br><span class="line">	<span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://www.shop.com/cart<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动加『-』"><a href="#自动加『-』" class="headerlink" title="自动加『/』"></a>自动加『/』</h3><p>有时候访问的地址要求后面以 <code>/</code> 结尾，那么我们需要解决如果用户忘记输入 <code>/</code>，Nginx 就会自动加上 <code>/</code>。</p>
<p>通过一个例子来演示问题：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想访问上述资源，很简单，只需要通过 <code>http://192.168.200.133</code> 直接就能访问，地址后面不需要加 /，但是如果将上述的配置修改为如下内容:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> /frx &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，要想访问上述资源，按照上述的访问方式，我们可以通过 <code>http://192.168.200.133/frx/</code> 来访问，但是如果地址后面不加斜杠，如 <code>http://192.168.200.133/frx</code>，页面就会出问题。如果不加斜杠，Nginx 服务器内部会自动做一个 301 的重定向，重定向的地址会有一个指令叫 <code>server_name_in_redirect</code> 来决定重定向的地址：</p>
<ul>
<li><p>如果该指令为 on</p>
<p>重定向的地址为：<code>http://server_name/目录名/</code></p>
</li>
<li><p>如果该指令为 off</p>
<p>重定向的地址为：<code>http://原URL中的域名/目录名/</code></p>
</li>
</ul>
<p>所以就拿刚才的地址来说，访问 <code>http://192.168.200.133/frx</code> 如果不加斜杠，那么按照上述规则：</p>
<ul>
<li>如果指令 <code>server_name_in_redirect</code> 为 on，则 301 重定向地址变为 <code>http://localhost/frx/</code>，IP 发生改变，地址出现了问题</li>
<li>如果指令 <code>server_name_in_redirect</code> 为 off，则 301 重定向地址变为 <code>http://192.168.200.133/frx/</code>。这个符合我们的期望</li>
</ul>
<p>注意 <code>server_name_in_redirect</code> 指令在 Nginx 的 0.8.48 版本之前默认都是 on，之后改成了 off，所以现在我们这个版本不需要考虑这个问题，但是如果是 0.8.48 以前的版本并且 server_name_in_redirect 设置为 on，我们如何通过 Rewrite 来解决这个问题？</p>
<p>解决方案</p>
<p>我们可以使用 Rewrite 功能为末尾没有斜杠的 URL 自动添加一个斜杠</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>	<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">server_name_in_redirect</span> <span class="literal">on</span>;</span><br><span class="line">	<span class="attribute">location</span> /frx &#123;</span><br><span class="line">		<span class="attribute">if</span> (-d <span class="variable">$request_filename</span>)&#123;   <span class="comment"># 如果请求的资源目录存在</span></span><br><span class="line">			<span class="attribute">rewrite</span><span class="regexp"> ^/(.*)([^/])$</span> http://<span class="variable">$host</span>/<span class="variable">$1</span><span class="variable">$2</span>/ <span class="literal">permanent</span>; <span class="comment"># $2 获取第二个括号的值：/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$1 是第一个括号的值，$2 是第二个括号的值。</p>
<h3 id="合并目录"><a href="#合并目录" class="headerlink" title="合并目录"></a>合并目录</h3><p>搜索引擎优化(SEO)是一种利用搜索引擎的搜索规则来提供目的网站的有关搜索引擎内排名的方式。我们在创建自己的站点时，可以通过很多中方式来有效的提供搜索引擎优化的程度。其中有一项就包含 URL 的目录层级，一般不要超过三层，否则的话不利于搜索引擎的搜索，也给客户端的输入带来了负担，但是将所有的文件放在一个目录下，又会导致文件资源管理混乱，并且访问文件的速度也会随着文件增多而慢下来，这两个问题是相互矛盾的，那么使用 Rewrite 如何解决这些问题呢？</p>
<p>举例，网站中有一个资源文件的访问路径 <code>/server/11/22/33/44/20.html</code>，也就是说 20.html 存在于第 5 级目录下，如果想要访问该资源文件，客户端的 URL 地址就要写成 <code>http://www.web.com/server/11/22/33/44/20.html</code>，并且在配置文件进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.web.com;</span><br><span class="line">	<span class="attribute">location</span> /server &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个是非常不利于 SEO 搜索引擎优化的，同时客户端也不好记。使用 Rewrite 的正则表达式，我们可以进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.web.com;</span><br><span class="line">    <span class="attribute">location</span> /server &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/server-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)\.html$</span>  /server/<span class="variable">$1</span>/<span class="variable">$2</span>/<span class="variable">$3</span>/<span class="variable">$4</span>/<span class="variable">$5</span>.html <span class="literal">last</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样配置后，客户端只需要输入 <code>http://www.web.com/server-11-22-33-44-20.html</code> 就可以访问到 20.html 页面了。这里也充分利用了 Rewrite 指令支持正则表达式的特性。</p>
<h3 id="多级域名"><a href="#多级域名" class="headerlink" title="多级域名"></a>多级域名</h3><p>当你配置了多级域名，如二级域名 <code>xxx.frxcat.fun</code>，并且静态资源目录恰好和二级域名的 <code>xxx</code> 可以匹配，则可以使用正则表达式进行匹配，日后，如果又多个 <code>xxx</code>，则再创建对应的该目录即可。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> ~^(.+)?.frxcat.fun$;</span><br><span class="line">    <span class="attribute">index</span> idnex.html;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$host</span> = frxcat.fun)&#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://www.frxcat.fun<span class="variable">$2</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">root</span> /data/html/<span class="variable">$1</span>/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样访问 <code>docs.frxcat.fun</code>，自动去 <code>/data/html/docs/</code> 目录下找到 index.html，如果是 <code>bing.youngkbt.cn</code>，则会去 <code>/data/html/bing/</code> 目录下找到 idnex.html，以此类推。</p>
<p>if 语句的作用是将 <code>frxcat.fun</code> 重定向到 <code>www.frxcat.fun</code>，这样既解决了网站的主目录访问，又可以增加 SEO 中对 <code>www.frxcat.fun</code> 的域名权重。</p>
<h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>防盗链之前我们已经介绍过了相关的知识，在 Rewrite 中的防盗链和之前将的原理其实都是一样的，只不过通过 Rewrite 可以将防盗链的功能进行完善下，当出现防盗链的情况，我们可以使用 Rewrite 将请求转发到自定义的一张图片和页面，给用户比较好的提示信息。</p>
<p>下面有两个配置实例：</p>
<ul>
<li>根据文件类型实现防盗链配置：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.web.com;</span><br><span class="line">	<span class="attribute">locatin</span> <span class="regexp">~* ^.+\.(gif|jpg|png|swf|flv|rar|zip)$</span> &#123;</span><br><span class="line">		<span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> server_names <span class="regexp">*.web.com</span>; <span class="comment"># server_names 后指定具体的域名或者 IP</span></span><br><span class="line">		<span class="attribute">if</span> (<span class="variable">$invalid_referer</span>)&#123;</span><br><span class="line">			<span class="attribute">rewrite</span><span class="regexp"> ^/</span> http://www.web.com/images/forbidden.png;  <span class="comment"># 跳转到默认地址</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据目录实现防盗链配置：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.web.com;</span><br><span class="line">	<span class="attribute">location</span> /file &#123;</span><br><span class="line">		<span class="attribute">root</span> /server/file;  <span class="comment"># 资源在 server 目录下的 file 目录里</span></span><br><span class="line">		<span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> server_names <span class="regexp">*.web.com</span>; <span class="comment"># server_names 后指定具体的域名或者 IP</span></span><br><span class="line">		<span class="attribute">if</span> (<span class="variable">$invalid_referer</span>)&#123;</span><br><span class="line">			<span class="attribute">rewrite</span><span class="regexp"> ^/</span> http://www.web.com/images/forbidden.png;  <span class="comment"># 跳转到 file 目录下的图片</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问限流"><a href="#访问限流" class="headerlink" title="访问限流"></a>访问限流</h2><p>我们构建网站是为了让用户访问它们，我们希望用于合法访问。所以不得不采取一些措施限制滥用访问的用户。这种滥用指的是从同一 IP 每秒到服务器请求的连接数。因为这可能是在同一时间内，世界各地的多台机器上的爬虫机器人多次尝试爬取网站的内容。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制用户连接数来预防 DOS 攻击</span></span><br><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=perip:<span class="number">10m</span>;</span><br><span class="line"><span class="attribute">limit_conn_zone</span> <span class="variable">$server_name</span> zone=perserver:<span class="number">10m</span>;</span><br><span class="line"><span class="comment"># 限制同一客户端 ip 最大并发连接数</span></span><br><span class="line"><span class="attribute">limit_conn</span> perip <span class="number">2</span>;</span><br><span class="line"><span class="comment"># 限制同一server最大并发连接数</span></span><br><span class="line"><span class="attribute">limit_conn</span> perserver <span class="number">20</span>;</span><br><span class="line"><span class="comment"># 限制下载速度，根据自身服务器带宽配置</span></span><br><span class="line"><span class="attribute">limit_rate</span> <span class="number">300k</span>;</span><br></pre></td></tr></table></figure>

<h2 id="链接超时"><a href="#链接超时" class="headerlink" title="链接超时"></a>链接超时</h2><p>长时间占着连接资源不释放，最终会导致请求的堆积，Nginx 处理请求效率大大降低。所以我们对连接的控制都要注意设置超时时间，通过超时机制自动回收资源、避免资源浪费。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端、服务端设置</span></span><br><span class="line"><span class="attribute">server_names_hash_bucket_size</span> <span class="number">128</span>;</span><br><span class="line"><span class="attribute">server_names_hash_max_size</span> <span class="number">512</span>;</span><br><span class="line"><span class="comment"># 长连接超时配置</span></span><br><span class="line"><span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"><span class="attribute">client_header_timeout</span> <span class="number">15s</span>;</span><br><span class="line"><span class="attribute">client_body_timeout</span> <span class="number">15s</span>;</span><br><span class="line"><span class="attribute">send_timeout</span> <span class="number">60s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理设置</span></span><br><span class="line"><span class="comment"># 与后端服务器建立连接的超时时间。注意这个一般不能大于 75 秒</span></span><br><span class="line"><span class="attribute">proxy_connect_timeout</span> <span class="number">30s</span>;</span><br><span class="line"><span class="attribute">proxy_send_timeout</span> <span class="number">120s</span>;</span><br><span class="line"><span class="comment"># 从后端服务器读取响应的超时</span></span><br><span class="line"><span class="attribute">proxy_read_timeout</span> <span class="number">120s</span>;</span><br></pre></td></tr></table></figure>

<h2 id="HTML引入"><a href="#HTML引入" class="headerlink" title="HTML引入"></a>HTML引入</h2><p>我们编写 .html 文件的时候，难免需要引入 css 和 js 文件，如果是在本地，那么引入非常简单，直接相对路径即可，但是部署到 Nginx 时，相对路径不再是相对 html 文件的目录，所以生产环境和开发环境的引入格式不一样。</p>
<p>在 Nginx 中的 .html 文件，引入 css 和 js，要加上 <code>/</code> 作为开头，<code>/</code> 代表 Nginx 的根目录，即配置文件 <code>location /</code> 的指定的 root 路径。</p>
<p>比如 Nginx 的配置文件内容如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/local/nginx/html; <span class="comment"># 静态文件根目录</span></span><br><span class="line">        <span class="attribute">index</span> idnex.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个 aa.html 在 <code>/usr/local/nginx/html/test</code> 目录下，并且 aa.html 引入了 aa.css 和 aa.js，两个静态文件在 aa.html 所在目录的 static 文件夹里。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/html/<span class="built_in">test</span> 目录</span><br><span class="line">├── a.html</span><br><span class="line">├── static</span><br><span class="line">│	├── a.css</span><br><span class="line">│	├── a.js</span><br></pre></td></tr></table></figure>

<p>在本地环境，我们可以这样写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"static/aa.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"static/aa.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是部署到 Nginx 后，这样写会找不到这两个资源，因为 <code>/</code> 触发 <code>location /</code>，进入 <code>/usr/local/nginx/html</code> 目录，而这两个文件在 <code>/usr/local/nginx/html/test/static</code> 目录下，所以我们部署到 Nginx 后，需要修改为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/test/static/aa.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/test/static/aa.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/10/Nginx_Basic_case_configuration/">Nginx 基础配置实例</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-基础配置实例"><a href="#Nginx-基础配置实例" class="headerlink" title="Nginx 基础配置实例"></a>Nginx 基础配置实例</h1><p><strong>引言</strong></p>
<p>学习了核心配置文件的内容，也仅仅是学习，没有实际例子来巩固的知识容易流失，本内容带你写一个简单的 demo 实例。</p>
<p>每次开机都手动启动 Nginx 服务？每次使用 Nginx 的指令总是要进入 sbin 目录下？本文带你配置 Naginx 服务自启和全局 nginx 指令。</p>
<h2 id="基础配置实例"><a href="#基础配置实例" class="headerlink" title="基础配置实例"></a>基础配置实例</h2><p>前面我们已经对 Nginx 服务器默认配置文件的结构和涉及的基本指令做了详细的阐述。通过这些指令的合理配置，我们就可以让一台 Nginx 服务器正常工作，并且提供基本的 Web 服务器功能。</p>
<p>接下来我们将通过一个比较完整和最简单的基础配置实例，来巩固下前面所学习的指令及其配置。</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul>
<li><p>有如下访问：</p>
<p><code>http://192.168.199.27:8081/server1/location1</code> 访问的是：index_sr1_location1.html <code>http://192.168.199.27:8081/server1/location2</code> 访问的是：index_sr1_location2.html <code>http://192.168.199.27:8082/server2/location1</code> 访问的是：index_sr2_location1.html <code>http://192.168.199.27:8082/server2/location2</code> 访问的是：index_sr2_location2.html</p>
</li>
<li><p>如果访问的资源不存在，返回自定义的 404 页面</p>
</li>
<li><p>将 /server1 和 /server2 的配置使用不同的配置文件分割，将两个文件文件放到 /home/www/conf.d 目录下，然后在 Nginx 的配置文件使用 include 合并两个文件</p>
</li>
<li><p>为 /server1 和 /server2 各自创建一个访问日志文件</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 404 页面</span></span><br><span class="line">touch /home/www/404.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 conf.d 目录</span></span><br><span class="line">mkdir /home/www/conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个配置文件</span></span><br><span class="line">touch /home/www/conf/server1.conf</span><br><span class="line">touch /home/www/conf/server2.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 myweb 目录</span></span><br><span class="line">mkdir /home/www/myweb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 server1 目录和其子目录以及 index.html 文件</span></span><br><span class="line">mkdir -p /home/www/myweb/server1/location1</span><br><span class="line">mkdir -p /home/www/myweb/server1/location2</span><br><span class="line"></span><br><span class="line">touch /home/www/myweb/server1/location1/index.html</span><br><span class="line">touch /home/www/myweb/server1/location2/index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建日志目录和日志文件</span></span><br><span class="line">mkdir -p /home/www/myweb/server1/logs</span><br><span class="line">touch /home/www/myweb/server1/logs/access.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 server2 目录和其子目录以及 index.html 文件</span></span><br><span class="line"><span class="comment"># 和创建 server1 步骤一样，把 1 改为 2 即可</span></span><br></pre></td></tr></table></figure>

<p>准备相关文件，/homw/www 目录如下：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220729/image.2fjy4216srrw.webp" alt="image"></p>
<p>因为 Nginx 自带配置文件的备份，即 nginx.conf.default，所以我们可以直接修改配置文件，但是如果你的配置文件曾经修改过，那么请进行备份。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf.backup</span><br></pre></td></tr></table></figure>

<p>备份后，进入 <code>/usr/local/nginx/conf/nginx.conf</code> 配置文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>先清空文件，然后添加如下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-lifetime=&quot;5&quot; :options=&quot;&#123; useUrlFragment: false &#125;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>有注释版</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> www; <span class="comment"># 配置允许运行 Nginx 工作进程的用户和用户组</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">2</span>;  <span class="comment"># 配置运行 Nginx 进程生成的 worker 进程数</span></span><br><span class="line"><span class="attribute">error_log</span> logs/error.log;  <span class="comment"># 配置 Nginx 服务器运行对错误日志存放的路径</span></span><br><span class="line"><span class="attribute">pid</span> logs/nginx.pid;   <span class="comment"># 配置 Nginx 服务器允许时记录 Nginx 的 master 进程的 PID 文件路径和名称</span></span><br><span class="line"><span class="attribute">daemon</span> <span class="literal">on</span>;   <span class="comment"># 配置 Nginx 服务是否以守护进程方法启动</span></span><br><span class="line"></span><br><span class="line">events&#123;</span><br><span class="line">	<span class="attribute">accept_mutex</span> <span class="literal">on</span>;   <span class="comment"># 设置 Nginx 网络连接序列化,解决惊群</span></span><br><span class="line">	<span class="attribute">multi_accept</span> <span class="literal">on</span>;   <span class="comment"># 设置 Nginx 的 worker 进程是否可以同时接收多个请求</span></span><br><span class="line">	<span class="attribute">worker_connections</span> <span class="number">1024</span>;   <span class="comment"># 设置 Nginx 的 worker 进程最大的连接数</span></span><br><span class="line">	<span class="attribute">use</span> <span class="literal">epoll</span>;   <span class="comment"># 设置 Nginx 使用的事件驱动模型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http&#123;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">include</span> mime.types;   <span class="comment"># 定义 MIME-Type</span></span><br><span class="line">	<span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">	<span class="attribute">sendfile</span> <span class="literal">on</span>;   <span class="comment"># 配置允许使用 sendfile 方式运输</span></span><br><span class="line">	<span class="attribute">keepalive_timeout</span> <span class="number">65</span>;   <span class="comment"># 配置连接超时时间</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 配置请求处理日志格式</span></span><br><span class="line">	<span class="attribute">log_format</span> server1 <span class="string">'===&gt;server1 access log'</span>;</span><br><span class="line">	<span class="attribute">log_format</span> server2 <span class="string">'===&gt;server2 access log'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="attribute">include</span> /home/www/conf/<span class="regexp">*.conf</span>;  <span class="comment"># 引用其他 conf 文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>无注释版</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> www;</span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">2</span>;</span><br><span class="line"><span class="attribute">error_log</span> logs/error.log;</span><br><span class="line"><span class="attribute">pid</span> logs/nginx.pid;</span><br><span class="line"><span class="attribute">daemon</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">events&#123;</span><br><span class="line">	<span class="attribute">accept_mutex</span> <span class="literal">on</span>;</span><br><span class="line">	<span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">	<span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">	<span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http&#123;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">include</span> mime.types;</span><br><span class="line">	<span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">	<span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">	<span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="attribute">log_format</span> server1 <span class="string">'===&gt;this is server1 access log'</span>;</span><br><span class="line">	<span class="attribute">log_format</span> server2 <span class="string">'===&gt;this is server2 access log'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="attribute">include</span> /home/www/conf/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 25 行代码使用 include 将 service1 和service2 的配置文件进行引用。以后无需修改主配置文件，只需要引入子配置文件即可，主配置文件作为默认值，子配置文件的内容会覆盖和主配置文件相同的内容。</p>
<p>进入 server1.conf 文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/www/conf/server1.conf</span><br></pre></td></tr></table></figure>

<p>server1.conf 文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-lifetime=&quot;5&quot; :options=&quot;&#123; useUrlFragment: false &#125;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>有注释版</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">8081</span>;   <span class="comment"># 配置监听端口和主机名称</span></span><br><span class="line">  <span class="attribute">server_name</span> localhost;</span><br><span class="line">  <span class="attribute">access_log</span> /home/www/myweb/server1/logs/access.log server1;   <span class="comment"># 配置请求处理日志存放路径</span></span><br><span class="line">  <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;   <span class="comment"># 配置错误页面</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> /server1/location1&#123;   <span class="comment"># 配置处理 /server1/location1 请求的 location</span></span><br><span class="line">      <span class="attribute">root</span> /home/www/myweb;</span><br><span class="line">      <span class="attribute">index</span> index.html;       <span class="comment"># 这是 server1 下的 location1 的 index.html</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> /server1/location2&#123;   <span class="comment"># 配置处理 /server1/location2 请求的 location</span></span><br><span class="line">      <span class="attribute">root</span> /home/www/myweb;</span><br><span class="line">      <span class="attribute">index</span> index.html;    <span class="comment"># 这是 server1 下的 location2 的 index.html</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;   <span class="comment"># 配置错误页面转向</span></span><br><span class="line">      <span class="attribute">root</span> /home/www;</span><br><span class="line">      <span class="attribute">index</span> <span class="number">404</span>.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>无注释版</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line">  <span class="attribute">server_name</span> localhost;</span><br><span class="line">  <span class="attribute">access_log</span> /home/www/myweb/server1/logs/access.log server1;</span><br><span class="line">  <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">location</span> /server1/location1&#123;</span><br><span class="line">      <span class="attribute">root</span> /home/www/myweb;</span><br><span class="line">      <span class="attribute">index</span> index.html;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">location</span> /server1/location2&#123;</span><br><span class="line">      <span class="attribute">root</span> /home/www/myweb;</span><br><span class="line">      <span class="attribute">index</span> index.html;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">      <span class="attribute">root</span> /home/www;</span><br><span class="line">      <span class="attribute">index</span> <span class="number">404</span>.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server2.conf 文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-lifetime=&quot;5&quot; :options=&quot;&#123; useUrlFragment: false &#125;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>有注释版</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">8082</span>;   <span class="comment"># 配置监听端口和主机名称</span></span><br><span class="line">  <span class="attribute">server_name</span> localhost;</span><br><span class="line">  <span class="attribute">access_log</span> /home/www/myweb/server2/logs/access.log server2;   <span class="comment"># 配置请求处理日志存放路径</span></span><br><span class="line">  <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;   <span class="comment"># 配置错误页面,对404.html做了定向配置</span></span><br><span class="line">  </span><br><span class="line">  <span class="attribute">location</span> /server2/location1&#123;   <span class="comment"># 配置处理 /server1/location1 请求的 location</span></span><br><span class="line">      <span class="attribute">root</span> /home/www/myweb;</span><br><span class="line">      <span class="attribute">index</span> index.html;   <span class="comment"># 这是 server2 下的 location1 的 index.html</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="attribute">location</span> /server2/location2&#123;   <span class="comment"># 配置处理 /server2/location2 请求的 location</span></span><br><span class="line">      <span class="attribute">root</span> /home/www/myweb;</span><br><span class="line">      <span class="attribute">index</span> index.html;    <span class="comment"># 这是 server2 下的 location2 的 index.html</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;   <span class="comment"># 配置错误页面转向</span></span><br><span class="line">      <span class="attribute">root</span> /home/www;</span><br><span class="line">      <span class="attribute">index</span> <span class="number">404</span>.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>无注解版</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">8082</span>;</span><br><span class="line">  <span class="attribute">server_name</span> localhost;</span><br><span class="line">  <span class="attribute">access_log</span> /home/www/myweb/server2/logs/access.log server2;</span><br><span class="line">  <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">location</span> /server2/location1&#123;</span><br><span class="line">      <span class="attribute">root</span> /home/www/myweb;</span><br><span class="line">      <span class="attribute">index</span> index.html;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">location</span> /server2/location2&#123;</span><br><span class="line">      <span class="attribute">root</span> /home/www/myweb;</span><br><span class="line">      <span class="attribute">index</span> index.html;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">      <span class="attribute">root</span> /home/www;</span><br><span class="line">      <span class="attribute">index</span> <span class="number">404</span>.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server1下面的location1下面的index.html的内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>server1下面的loaction1下面的index.html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其他的三个页面把数字改了就可以</p>
<p>404.html内容;</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>不好意思，程序小哥正在加紧维修中 ...... <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>重启 Nginx ，使得配置文件生效</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>如果没有关闭防火墙，记得开放 8081 和 8082 端口。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放 8081 和 8082 端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8081/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=8082/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>打开浏览器分别访问，效果如图所示：</p>
<p>8081 的 server1 的 location1：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220729/image.8hg9dg1p4z0.webp" alt="image"></p>
<p>8081 的 server1 的 location2：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220729/image.2dphfquey6v4.webp" alt="image"></p>
<p>8082 的 server2 的 location1：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220729/image.rfbc49fqpmo.webp" alt="image"></p>
<p>8082 的 server2 的 location2：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220729/image.1m80pe5hx1q8.webp" alt="image"></p>
<p>如果访问一个不存在的 404 请求：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220729/image.3fccke6ob8c0.webp" alt="image"></p>
<p>日志也会打印，这里演示一个：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@master www]<span class="comment"># tail /home/www/myweb/server1/logs/access.log</span></span><br><span class="line">===&gt;this is server1 access <span class="built_in">log</span></span><br><span class="line">===&gt;this is server1 access <span class="built_in">log</span></span><br><span class="line">===&gt;this is server1 access <span class="built_in">log</span></span><br><span class="line">===&gt;this is server1 access <span class="built_in">log</span></span><br><span class="line">===&gt;this is server1 access <span class="built_in">log</span></span><br><span class="line">===&gt;this is server1 access <span class="built_in">log</span></span><br><span class="line">===&gt;this is server1 access <span class="built_in">log</span></span><br><span class="line">===&gt;this is server1 access <span class="built_in">log</span></span><br><span class="line">===&gt;this is server1 access <span class="built_in">log</span></span><br><span class="line">===&gt;this is server1 access <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<h2 id="操作的问题"><a href="#操作的问题" class="headerlink" title="操作的问题"></a>操作的问题</h2><p>经过前面的操作，我们会发现，如果想要启动、关闭或重新加载 Nginx 配置文件，都需要先进入到 Nginx 的安装目录的 sbin 目录，然后使用 Nginx 的二级制可执行文件 nginx 来操作，相对来说操作比较繁琐，这块该如何优化？另外如果我们想把 Nginx 设置成随着服务器启动就自动完成启动操作，又该如何来实现？</p>
<p>这就需要用到接下来我们要讲解的两个知识点：</p>
<ul>
<li>Nginx 服务启停配置</li>
<li>Nginx 全局命令配置</li>
</ul>
<h2 id="服务启停配置"><a href="#服务启停配置" class="headerlink" title="服务启停配置"></a>服务启停配置</h2><p>把 Nginx 应用服务设置成为系统服务，方便对 Nginx 服务的启动和停止等相关操作，具体实现步骤:</p>
<ul>
<li>在 <code>/usr/lib/systemd/system</code> 目录下创建 nginx.service 文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure>

<p>文件添加如下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx web service</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/<span class="built_in">local</span>/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -t -c /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br><span class="line">ExecReload=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s stop</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure>

<p>注意：可执行文件 nginx 根据自己的路径进行修改，以及 .conf 配置文件和 .pid 文件的路径。这份内容是基于默认安装目录的。</p>
<ul>
<li>添加完成后，如果权限有问题需要进行权限设置，没有则忽略这一步</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure>

<ul>
<li>使用系统命令来操作 Nginx 服务</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 Nginx</span></span><br><span class="line">systemctl start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 Nginx</span></span><br><span class="line">systemctl stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 Nginx</span></span><br><span class="line">systemctl restart nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置文件</span></span><br><span class="line">systemctl reload nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Nginx 状态</span></span><br><span class="line">systemctl status nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭开启启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> nginx</span><br></pre></td></tr></table></figure>

<h2 id="全局命令配置"><a href="#全局命令配置" class="headerlink" title="全局命令配置"></a>全局命令配置</h2><p>前面我们介绍过 Nginx 安装目录下的二级制可执行文件 <code>nginx</code> 的很多命令，要想使用这些命令前提是需要进入 sbin 目录下才能使用，很不方便，如何去优化，我们可以将该二进制可执行文件加入到系统的环境变量，这样的话在任何目录都可以使用 nginx 对应的相关命令。具体实现步骤如下:</p>
<p>方法一：</p>
<ul>
<li>修改 <code>/etc/profile</code> 文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在最后一行添加</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<p>可执行文件 nginx 的路径根据自己的路径修改，这里是默认路径。</p>
<ul>
<li>使之立即生效</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<ul>
<li>任意位置执行 nginx 命令，测试成功</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># nginx -v</span></span><br><span class="line">nginx version: nginx/1.21.6</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<ul>
<li>将可执行文件 nginx 拷贝一份到 /usr/bin 目录下</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/nginx/sbin/nginx /usr/bin</span><br></pre></td></tr></table></figure>

<ul>
<li>任意位置执行 nginx 命令，测试成功</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># nginx -v</span></span><br><span class="line">nginx version: nginx/1.21.6</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/10/Nginx_Configuration_file/">Nginx 核心配置文件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-核心配置文件"><a href="#Nginx-核心配置文件" class="headerlink" title="Nginx 核心配置文件"></a>Nginx 核心配置文件</h1><p>从前面的内容学习中，我们知道 Nginx 的核心配置文件默认是放在 <code>/usr/local/nginx/conf/nginx.conf</code>，本次我们就来学习下 nginx.conf 的内容和基本配置方法。</p>
<hr>
<h2 id="配置文件内容"><a href="#配置文件内容" class="headerlink" title="配置文件内容"></a>配置文件内容</h2><p>读取 Nginx 自带的 Nginx 配置文件，配置文件内容很多，我们先将其中的注释部分【学习一个技术点就是在 Nginx 的配置文件中可以使用 <code>#</code> 来注释】删除掉后，就剩下如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;   <span class="comment"># 使用指令 1 </span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;    <span class="comment"># 这是 events 块</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;    <span class="comment"># 这是 http 块</span></span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;   <span class="comment"># 监听 80 端口</span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost;   <span class="comment"># 监听请求过来的 IP</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;   <span class="comment"># 请求的地址是 /，则进入这个配置，访问 idnex.html</span></span><br><span class="line">            <span class="attribute">root</span>   html;      <span class="comment"># 进入 html 目录找到访问的页面</span></span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 如果访问的页面是 500 502 503 504，则发送 /50x.html 请求</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;  </span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;      <span class="comment"># 如果匹配上 /50x.html 请求</span></span><br><span class="line">            <span class="attribute">root</span>   html;     <span class="comment"># 则进入 html 目录找到 /50x.html</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上面文件内容的解释，一一对应比较解释：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">指令名	指令值;  # 全局块，主要设置 Nginx 服务器整体运行的配置指令</span><br><span class="line"></span><br><span class="line"><span class="comment"># events 块，主要设置 Nginx 服务器与用户的网络连接,这一部分对 Nginx 服务器的性能影响较大</span></span><br><span class="line"><span class="section">events</span> &#123;	 </span><br><span class="line">    指令名	指令值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># http 块，是 Nginx 服务器配置中的重要部分，代理、缓存、日志记录、第三方模块配置...             </span></span><br><span class="line"><span class="section">http</span> &#123;		</span><br><span class="line">    指令名	指令值;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123; 		<span class="comment"># server 块，是 Nginx 配置和虚拟主机相关的内容</span></span><br><span class="line">        指令名	指令值;</span><br><span class="line">        <span class="attribute">location</span> / &#123;      <span class="comment"># location 块，基于 Nginx 服务器接收请求字符串与 location 后面的值进行匹配，对特定请求进行处理</span></span><br><span class="line">            指令名	指令值;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>nginx.conf 配置文件中默认有三大块：全局块、events 块、http 块</p>
<p>http 块中可以配置多个 server 块，每个 server 块又可以配置多个 location 块。</p>
<h2 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h2><p>全局块的配置影响 Nginx 的全局设置。如用户权限，启动的进程数等。</p>
<h3 id="user指令"><a href="#user指令" class="headerlink" title="user指令"></a>user指令</h3><ol>
<li>user：用于配置运行 Nginx 服务器的 worker 进程的用户和用户组。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>user &lt;user&gt; [group]</td>
<td>nobody</td>
<td>全局块</td>
</tr>
</tbody></table>
<p>该属性也可以在编译的时候指定，语法如下 <code>./configure --user=user --group=group</code>，如果两个地方都进行了设置，最终生效的是配置文件中的配置。</p>
<p>该指令的使用步骤:</p>
<ol>
<li>进入配置文件添加一个用户信息 『 www 』</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user www</span><br></pre></td></tr></table></figure>

<p>测试进行测试配置文件会报错：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master conf]<span class="comment"># nginx -t</span></span><br><span class="line">nginx: [emerg] getpwnam(<span class="string">"www"</span>) failed <span class="keyword">in</span> /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf:1</span><br><span class="line">nginx: configuration file /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf <span class="built_in">test</span> failed</span><br></pre></td></tr></table></figure>

<p>原因在于 Linux 系统不存在 www 用户，我们需要创建它。</p>
<ol start="2">
<li>创建一个用户</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd www</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重启 Nginx 的配置文件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看重启是否生效</span></span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure>

<p>最后返回的结果由 root 用户改为 www 用户，代表配置成功。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master conf]<span class="comment"># ps -ef | grep nginx</span></span><br><span class="line">root       8960      1  0 16:13 ?        00:00:00 nginx: master process ./nginx</span><br><span class="line">www       11975   8960  0 20:44 ?        00:00:00 nginx: worker process</span><br><span class="line">root      11978  10615  0 20:44 pts/1    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 Linux 的 <code>/root</code> 下创建一个 html 目录，并且进入 html 目录，创建 index.html 文件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/html</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /root/html</span><br><span class="line"></span><br><span class="line">vim index.html</span><br></pre></td></tr></table></figure>

<p>然后在 <code>/root/html/index.html</code> 文件里添加如下内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>For online documentation and support please refer to</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://nginx.org/"</span>&gt;</span>nginx.org<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">Commercial support is available at</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://nginx.com/"</span>&gt;</span>nginx.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Thank you for using nginx.<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>I am WWW<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这些内容其实就是在 Nginx 的欢迎页面上多加别 <code>I am WWW</code> 内容。</p>
<ol start="5">
<li>修改 nginx.conf</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">	<span class="comment"># root   html;  # 原始的代码注释掉</span></span><br><span class="line">	<span class="attribute">root</span>   /root/html;    <span class="comment"># 不再是 html 目录，而是 root 下的 html 目录</span></span><br><span class="line">	<span class="attribute">index</span>  index.html index.htm;  <span class="comment"># 就是上方创建的 index.html</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>nginx -s reload</code>重新加载后，测试启动访问</li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220728/image.6dtnfz58zpo0.webp" alt="image"></p>
<p> 页面会报 403 拒绝访问的错误。</p>
<ol start="7">
<li>分析原因：因为当前用户（www 用户）没有访问 <code>/root/html</code> 目录的权限，这个目录只有 root 才能访问。</li>
</ol>
<p>那么 www 如何访问我们写的 index.html 页面呢？我们知道，每新建一个用户，<code>/home</code> 下都会生成该用户权限的目录。</p>
<ol start="8">
<li>将文件移动到 <code>/home/www/html/index.html</code></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /root/html /home/www</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>记得修改配置文件的资源内容</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">	<span class="comment"># root   html;  # 原始的代码注释掉</span></span><br><span class="line">	<span class="comment"># root   /root/html;   # 这属于 root 权限的页面，注释或者删除掉</span></span><br><span class="line">	<span class="attribute">root</span>   /home/www/html;  <span class="comment"># 这是 www 用户有权限访问的目录</span></span><br><span class="line">	<span class="attribute">index</span>  index.html index.htm;   <span class="comment"># 访问了 html 目录，然后访问 index.html 文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>再次测试启动访问，可以正常访问。</li>
</ol>
<p>综上所述，使用 user 指令可以指定启动运行工作进程的用户及用户组，这样对于系统的权限访问控制的更加精细，也更加安全。</p>
<p>我们也能理解了配置文件的 <code>locaotion</code> 块的基本使用，root 对应着访问目录，index 对应着访问目录下的默认页面。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220728/image.6igjptnd6eo0.webp" alt="image"></p>
<h3 id="work-process指令"><a href="#work-process指令" class="headerlink" title="work process指令"></a>work process指令</h3><ol>
<li><code>master_process</code> 指令用来指定是否开启 worker 工作进程。</li>
</ol>
<p>如果为 off，则代表关闭了 worker 进程，这时候启动 Nginx，只有 master 进程启动，没有 worker 进程。默认开启 worker 工作进程。(<mark>需要重启nginx服务生效</mark>)</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>master_process &lt;on | off&gt;;</td>
<td>master_process on;</td>
<td>全局块</td>
</tr>
</tbody></table>
<ol start="2">
<li><p><code>worker_processes</code> 指令用于配置 Nginx 生成 worker 工作进程的数量，这个是 Nginx 服务器实现并发处理</p>
<p>服务的关键所在。</p>
</li>
</ol>
<p>理论上来说 <code>workder process</code> 的值越大，可以支持的并发处理量也越多，但事实上这个值的设定是需要受到来自服务器自身的限制，建议将该值和服务器 CPU 的内核数保存一致。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>worker_processes &lt;num | auto&gt;;</td>
<td>1</td>
<td>全局块</td>
</tr>
</tbody></table>
<p>如果将 <code>worker_processes</code> 设置成 2，则会看到如下内容:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master conf]<span class="comment"># ps -ef | grep nginx</span></span><br><span class="line">root       8960      1  0 16:13 ?        00:00:00 nginx: master process ./nginx</span><br><span class="line">www       12299   8960  0 21:14 ?        00:00:00 nginx: worker process</span><br><span class="line">www       12300   8960  0 21:14 ?        00:00:00 nginx: worker process</span><br><span class="line">root      12302  10615  0 21:14 pts/1    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure>

<p>出现两个 worker 工作进程。</p>
<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><ol>
<li><code>daemon</code> 指令设置 Nginx 是否以守护进程的方式启动。on 代表开启守护进程，off 代表关闭守护进程，默认开启。(<mark>需要重启nginx生效</mark>)</li>
</ol>
<p>守护式进程是 Linux 后台执行的一种服务进程，特点是 <strong>独立于控制终端，不会随着终端关闭而停止</strong>，也就是后台启动。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>daemon &lt;on | off&gt;;</td>
<td>daemon on;</td>
<td>全局块</td>
</tr>
</tbody></table>
<ol start="2">
<li><code>pid</code> 指令用来配置 Nginx 当前 master 进程的进程号 ID 存储的文件路径。默认路径是 <code>/usr/local/nginx/logs/nginx.pid</code>。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>pid &lt;file&gt;;</td>
<td>/usr/local/nginx/logs/nginx.pid</td>
<td>全局块</td>
</tr>
</tbody></table>
<p>该属性也可以通过 <code>./configure --pid-path=PATH</code> 在编译时来指定。</p>
<ol start="3">
<li><code>error_log</code> 指令用来配置 Nginx 的错误日志存放路径。默认路径是 <code>/usr/local/nginx/logs/error.log</code>。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>error_log &lt;file&gt; [日志级别];</td>
<td>error_log logs/error.log error;</td>
<td>全局块、http、server、location</td>
</tr>
</tbody></table>
<p>该属性也可以通过 <code>./configure --error-log-path=PATH</code> 在编译时来指定。</p>
<p>其中日志级别的值有『 debug | info | notice | warn | error | crit | alert | emerg 』，翻译过来为「调试 | 信息 | 通知 | 警告 | 错误 | 临界 | 警报 | 紧急」，这块建议大家设置的时候不要设置成 info 以下的等级，因为会带来大量的磁盘 I/O 消耗，影响 Nginx 的性能。</p>
<ol start="4">
<li><code>include</code> 指令用来引入其他的配置文件，使 Nginx 的配置更加灵活。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>include &lt;file&gt;;</td>
<td>无</td>
<td>any</td>
</tr>
</tbody></table>
<h2 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h2><h3 id="events指令"><a href="#events指令" class="headerlink" title="events指令"></a>events指令</h3><ol>
<li><code>accept_mutex</code> 指令用来设置是否开启 Nginx 网络连接序列化。默认开启。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>accept_mutex &lt;on | off&gt;;</td>
<td>accept_mutex on;</td>
<td>events</td>
</tr>
</tbody></table>
<p>这个配置主要可以用来解决常说的「惊群」问题。大致意思是在某一个时刻，客户端发来一个请求连接，Nginx 后台是以多进程的工作模式，也就是说有多个 worker 进程会被同时唤醒，但是最终只会有一个进程可以获取到连接，如果每次唤醒的进程数目太多，就会影响 Nginx 的整体性能。如果将上述值设置为 on (开启状态)，将会对多个 Nginx 进程接收连接进行序列号，一个个来唤醒接收，就防止了多个进程对连接的争抢。</p>
<p>如图的小狗，如果只是一块「骨头」出现，则只需要唤醒一个小狗即可（开启 on），如果多个「骨头」如三个同时出现，那么唤醒三个小狗效率更高（此时需要设置 off）</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220728/image.118zwwf8v268.webp" alt="image"></p>
<ol start="2">
<li><code>multi_accept</code> 指令用来设置是否开启同时接收多个网络连接。默认开启。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>multi_accept &lt;on | off&gt;;</td>
<td>multi_accept off;</td>
<td>events</td>
</tr>
</tbody></table>
<p>如果 multi_accept 被禁止了，Nginx 的一个工作进程只能同时接受一个新的连接。如果开启，一个工作进程可以同时接受所有的新连接。<strong>建议开启。</strong></p>
<ol start="3">
<li><code>worker_connections</code> 指令用来配置单个 worker 进程最大的连接数。默认 512 个连接数。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>worker_connections &lt;number&gt;;</td>
<td>worker_commections 512;</td>
<td>events</td>
</tr>
</tbody></table>
<p>这里的连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数。另外，number 值不能大于操作系统支持打开的最大文件句柄数量。</p>
<ol start="4">
<li><code>use</code> 指令用来设置 Nginx 服务器选择哪种事件驱动来处理网络消息。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>use &lt;method&gt;;</td>
<td>根据操作系统规定</td>
<td>events</td>
</tr>
</tbody></table>
<p>注意：此处所选择事件处理模型是 Nginx 优化部分的一个重要内容，method 的可选值有『 select | poll | epoll | kqueue 』等，之前在准备 Centos 环境的时候，我们强调过要使用 Linux 内核在 2.6 以上，就是为了能使用 epoll 函数来优化 Nginx。</p>
<p>另外这些值的选择，我们也可以在编译的时候使用 <code>--with-select_module</code>、<code>--without-select_module</code>、<code>--with-poll_module</code>、<code>--without-poll_module</code> 来设置是否需要将对应的事件驱动模块编译到 Nginx 的内核。</p>
<h3 id="events指令配置模板"><a href="#events指令配置模板" class="headerlink" title="events指令配置模板"></a>events指令配置模板</h3><p>打开 Nginx 的配置文件 nginx.conf，添加如下配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events&#123;</span><br><span class="line">	<span class="attribute">accept_mutex</span> <span class="literal">on</span>;    <span class="comment"># 开启 Nginx 网络连接序列化</span></span><br><span class="line">	<span class="attribute">multi_accept</span> <span class="literal">on</span>;    <span class="comment"># 开启同时接收多个网络连接</span></span><br><span class="line">	<span class="attribute">worker_commections</span> <span class="number">1024</span>;   <span class="comment"># 单个 worker 进程最大的连接数</span></span><br><span class="line">	<span class="attribute">use</span> <span class="literal">epoll</span>;   <span class="comment"># 使用 epoll 函数来优化 Nginx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动测试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试配置是否语法出错</span></span><br><span class="line">nginx -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载 Nginx</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<h2 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h2><h3 id="定义MIME-Type"><a href="#定义MIME-Type" class="headerlink" title="定义MIME-Type"></a>定义MIME-Type</h3><p>我们都知道浏览器中可以显示的内容有 HTML、XML、GIF 等种类繁多的文件、媒体等资源，浏览器为了区分这些资源，就需要使用 MIME Type。所以说 MIME Type 是网络资源的媒体类型。Nginx 作为 Web 服务器，也需要能够识别前端请求的资源类型。</p>
<p>在 Nginx 的配置文件中，默认有两行配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include mime.types;      <span class="comment"># 引入 mime.types 文件的内容</span></span><br><span class="line">default_type application/octet-stream;     <span class="comment"># 默认的 MIME 类型</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>default_type</code> 指令用来配置 Nginx 响应前端请求默认的 MIME 类型。默认是 text 文本。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>default_type &lt;mime-type&gt;;</td>
<td>default_type text/plain;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>在 <code>default_type</code> 前面还有一句 <code>include mime.types</code>，include 之前我们已经介绍过，相当于把 mime.types 文件中 MIMT 类型与相关类型文件的文件后缀名的对应关系加入到当前的配置文件中。</p>
<p>举例来说明：</p>
<p>有些时候请求某些接口的时候需要返回指定的文本字符串或者 json 字符串，而不是页面，如果逻辑非常简单或者干脆是固定的字符串，那么可以使用 Nginx 快速实现，这样就不用编写程序响应请求了，可以减少服务器资源占用并且响应性能非常快。</p>
<p>如何实现：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /get_text &#123;</span><br><span class="line">    <span class="attribute">default_type</span> text/html;      <span class="comment"># 等价于 text/plain，返回文本类型</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">"&lt;h1&gt;This is nginx's text&lt;/h1&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> /get_json&#123;</span><br><span class="line">    <span class="attribute">default_type</span> application/json;   <span class="comment"># 返回 json 字符串类型</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">'&#123;"name": "xiaoming", "age": 21&#125;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220728/image.1joqriwre9j4.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220728/image.47ty7dkhzmi0.webp" alt="image"></p>
<h3 id="自定义服务日志"><a href="#自定义服务日志" class="headerlink" title="自定义服务日志"></a>自定义服务日志</h3><p>Nginx 中日志的类型分 access.log、error.log。</p>
<p><code>access.log</code> 日志用来记录用户所有的访问请求。</p>
<p><code>error.log</code> 日志记录 Nginx 本身运行时的错误信息，不会记录用户的访问请求。</p>
<p>Nginx 服务器支持对服务日志的格式、大小、输出等进行设置，需要使用到两个指令，分别是 <code>access_log</code> 和 <code>log_format</code> 指令。</p>
<ol>
<li><code>access_log</code> 指令用来设置用户访问日志的相关属性。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>access_log &lt;path&gt; [format[buffer=size]];</td>
<td>access_log logs/access.log combined;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>format 对应着 <code>log_format</code> 的 name，必须保持一致。</p>
<ol start="2">
<li><code>log_format</code> 指令用来指定日志的输出格式。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>log_format &lt;name&gt; [escape=default | json | none] &lt;string&gt; …… ;</td>
<td>log_format combined “…”;</td>
<td>http</td>
</tr>
</tbody></table>
<p>name 对用 <code>access_log</code> 的 format，必须保持一致。</p>
<blockquote>
<p><strong>例子 1：自定义日志路径和输出格式</strong></p>
</blockquote>
<ul>
<li>在 <code>/usr/local/nginx/logs</code> 下创建 my.log 文件，该文件作为日志。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/nginx/logs/my.log</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义日志输出格式：<code>==========&gt;This is My format</code></li>
<li>在配置文件配置相关指令</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> myformat <span class="string">'=========&gt;This is My format'</span>;</span><br><span class="line"><span class="attribute">access_log</span> logs/my.log myformat;</span><br></pre></td></tr></table></figure>

<ul>
<li>重启服务并进行测试</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启 Nginx 服务</span></span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听日志</span></span><br><span class="line">tail -f /usr/<span class="built_in">local</span>/nginx/logs/my.log</span><br></pre></td></tr></table></figure>

<p>浏览器访问一次 Nginx 的欢迎页面，回来看日志的输出，结果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220728/image.5t1f8j2rclc0.webp" alt="image"></p>
<blockquote>
<p><strong>例子 2：输出内容加上访问机器的信息</strong></p>
</blockquote>
<ul>
<li>进入配置文件，在输出格式上加上 Nginx 的内置参数</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> myformat <span class="string">'=========&gt;This is My format:<span class="variable">$http_user_agent</span>'</span>;</span><br><span class="line"><span class="attribute">access_log</span> logs/my.log myformat;</span><br></pre></td></tr></table></figure>

<ul>
<li>重启测试</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启 Nginx 服务</span></span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听日志</span></span><br><span class="line">tail -f /usr/<span class="built_in">local</span>/nginx/logs/my.log</span><br></pre></td></tr></table></figure>

<p>浏览器访问一次 Nginx 的欢迎页面，回来看日志的输出，结果如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220728/image.2rkljjc3tlk0.webp" alt="image"></p>
<h3 id="其他配置指令"><a href="#其他配置指令" class="headerlink" title="其他配置指令"></a>其他配置指令</h3><ol>
<li><code>sendfile</code>：用来设置 Nginx 服务器是否使用 sendfile 传输文件，该属性可以大大提高 Nginx 处理静态资源的性能。默认关闭，建议开启。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>sendfile &lt;on | off&gt;;</td>
<td>sendfile off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ol start="2">
<li><code>keepalive_timeout</code>：用来设置长连接的超时时间，默认超时时间是 75 秒。</li>
</ol>
<p><strong>为什么要使用 keepalive？</strong></p>
<p>我们都知道 HTTP 是一种无状态协议，客户端向服务端发送一个 TCP 请求，服务端响应完毕后断开连接。</p>
<p>如何客户端向服务端发送多个请求，每个请求都需要重新创建一次连接，效率相对来说比较多，使用 keepalive 模式，可以告诉服务器端在处理完一个请求后保持这个 TCP 连接的打开状态，若接收到来自这个客户端的其他请求，服务端就会利用这个未被关闭的连接，而不需要重新创建一个新连接，提升效率，但是这个连接也不能一直保持，这样的话，连接如果过多，也会是服务端的性能下降，这个时候就需要我们进行设置其的超时时间。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>keepalive_timeout &lt;time&gt;;</td>
<td>keepalive_timeout 75s;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ol start="3">
<li><code>keepalive_requests</code>：用来设置一个 keep-alive 连接使用的次数，默认是 100 次。</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>keepalive_requests &lt;number&gt;;</td>
<td>keepalive_requests 100;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<h2 id="server块和location块"><a href="#server块和location块" class="headerlink" title="server块和location块"></a>server块和location块</h2><p>server 块和 location 块都是我们要重点学习的内容，因为我们后面会对 Nginx 的功能进行详细讲解，所以该内容在<strong>静态资源部署</strong>和<strong>静态资源访问</strong>进行详细说明。</p>
<p>本次我们这是认识下 Nginx 默认给的 nginx.conf 中的相关内容，以及 server 块与 location 块在使用的时候需要注意的一些内容。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span>       <span class="number">80</span>;     <span class="comment"># 监听 80 端口，如果更改端口，则外界访问的时候带上对应的端口号，如 8080</span></span><br><span class="line">	<span class="attribute">server_name</span>  localhost;  <span class="comment"># 指定可以访问 Nginx 的 IP 地址</span></span><br><span class="line">	</span><br><span class="line">	<span class="attribute">location</span> / &#123;      </span><br><span class="line">		<span class="attribute">root</span>   html;    <span class="comment"># 访问资源所对应的目录，这里是 html 目录</span></span><br><span class="line">		<span class="attribute">index</span>  index.html index.htm;    <span class="comment"># 访问资源所对应目录下的默认页面，优先级递增</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> <span class="number">404</span>  /50x.html;  <span class="comment"># 访问错误，跳转访问 /50x.html 请求</span></span><br><span class="line">	<span class="attribute">location</span> = /50x.html &#123;   <span class="comment"># 访问 /50x.html 请求的处理</span></span><br><span class="line">		<span class="attribute">root</span>   html;    <span class="comment"># 访问资源所对应的目录，这里是 html 目录的 50x.html</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>listen 和 server_name 是我们的 <code>http://server_name:listen</code>，如 <code>http://localhost:80</code></li>
<li>location / 就是访问 <code>http://server_name:listen/</code>，里面的配置对应着 <code>http://server_name:listen/html/index.html</code></li>
<li>页面产生 500 502 503 504 404，就会发送 <code>http://server_name:listen/50x.html</code></li>
<li>location = /50x.html 就是 <code>http://server_name:listen/50x.html</code>，它会自动访问 <code>http://server_name:listen/html/50x.html</code></li>
<li>root 代表资源目录指令</li>
<li>index 代表默认访问网页指令</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/10/Nginx_Static_resource_deployment/">Nginx 静态资源部署</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/后端/">后端</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx/">Nginx</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/中间件/">中间件</a></span><div class="content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="Nginx-静态资源部署"><a href="#Nginx-静态资源部署" class="headerlink" title="Nginx 静态资源部署"></a>Nginx 静态资源部署</h1><p><strong>引言</strong></p>
<p>静态资源如何部署？本内容带你了解静态资源相关的操作和内容。</p>
<p>静态资源指令配置、静态资源优化配置、静态资源压缩配置、静态资源缓存配置。</p>
<h2 id="Nginx静态资源概述"><a href="#Nginx静态资源概述" class="headerlink" title="Nginx静态资源概述"></a>Nginx静态资源概述</h2><p>上网去搜索访问资源对于我们来说并不陌生，通过浏览器发送一个 HTTP 请求实现从客户端发送请求到服务器端获取所需要内容后并把内容回显展示在页面的一个过程。这个时候，我们所请求的内容就分为两种类型，一类是静态资源、一类是动态资源。</p>
<p>静态资源即指在服务器端真实存在并且能直接拿来展示的一些文件，比如常见的 html 页面、css 文件、js 文件、图片、视频等资源；</p>
<p>动态资源即指在服务器端真实存在但是要想获取需要经过一定的业务逻辑处理，根据不同的条件展示在页面不同这 一部分内容，比如说报表数据展示、根据当前登录用户展示相关具体数据等资源；</p>
<p>Nginx 处理静态资源的内容，我们需要考虑下面这几个问题：</p>
<ul>
<li>静态资源的配置指令</li>
<li>静态资源的配置优化</li>
<li>静态资源的压缩配置指令</li>
<li>静态资源的缓存处理</li>
<li>静态资源的访问控制，包括跨域问题和防盗链问题</li>
</ul>
<h2 id="静态资源指令配置"><a href="#静态资源指令配置" class="headerlink" title="静态资源指令配置"></a>静态资源指令配置</h2><h3 id="listen指令"><a href="#listen指令" class="headerlink" title="listen指令"></a>listen指令</h3><p>该指令是用来配置监听端口。默认监听 80（root 启动 Nginx） 和 8000（非 root 启动 Nginx） 端口。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>listen &lt;address&gt;[:port] [default_server] …… ;<br> listen &lt;port&gt; [default_server] …… ;</td>
<td>listen *:80 | *:8000</td>
<td>server</td>
</tr>
</tbody></table>
<p><code>listen</code> 指令的设置比较灵活，我们通过几个例子来把常用的设置方式熟悉下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listen 127.0.0.1:8000; <span class="comment"># listen localhost:8000 监听指定的IP和端口</span></span><br><span class="line">listen 127.0.0.1;	<span class="comment"># 监听指定IP的所有端口</span></span><br><span class="line">listen 8000;	<span class="comment"># 监听指定端口上的连接</span></span><br><span class="line">listen *:8000;	<span class="comment"># 监听指定端口上的连接</span></span><br></pre></td></tr></table></figure>

<p><code>default_server</code> 属性是标识符，用来将此虚拟主机设置成默认主机。所谓的默认主机指的是如果没有匹配到对应的 <code>address:port</code>，则会执行默认的 server。如果不指定该标识符，又没有匹配到对应的 <code>address:port</code> 时，默认使用的是第一个 server，所以第一个 server 要好好设置，建议第一个 server 就加上 <code>default_server</code>。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">8080</span> default_server;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">444</span> <span class="string">'This is a error request'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时访问 8080 端口，它会访问第二个 server，如果第二个 server 去掉 <code>default_server</code> ，则默认访问第一个 server。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220730/image.2e5c4uo1ghlw.webp" alt="image"></p>
<h3 id="server-name指令"><a href="#server-name指令" class="headerlink" title="server_name指令"></a>server_name指令</h3><p>该指令用来设置虚拟主机服务名称。默认为空。</p>
<p>比如 127.0.0.1、localhost、域名[<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> | <a href="http://www.jd.com]。" target="_blank" rel="noopener">www.jd.com]。</a></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>server_name &lt;name&gt; …… ;</td>
<td>server_name “”;</td>
<td>server</td>
</tr>
</tbody></table>
<ul>
<li>name 可以提供多个中间用空格分隔。</li>
</ul>
<p>关于 server_name 的配置方式有三种，分别是：</p>
<ul>
<li>精确匹配</li>
<li>通配符匹配</li>
<li>正则表达式匹配</li>
</ul>
<blockquote>
<p><strong>配置方式一：精确匹配</strong></p>
</blockquote>
<p>如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.frx.com www.bing.com;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时以 <code>www.frx.com</code> 或者 <code>www.bing.com</code> 域名进行访问，就会跳转到 Nginx 的欢迎页面，前提是你需要拥有该域名，并且该域名和 Nginx 所在的系统 IP 进行绑定。</p>
<p>所以我可以利用 hosts 文件进行「模拟」域名。</p>
<blockquote>
<p>补充小知识点</p>
</blockquote>
<p>hosts 是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联「数据库」，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从 hosts 文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交 DNS 域名解析服务器进行 IP 地址的解析。</p>
<p>hosts 文件不同系统的位置：</p>
<ul>
<li>在 windows 的位置：C:\Windows\System32\drivers\etc</li>
<li>在 centos 的位置：/etc/hosts</li>
</ul>
<p>因为域名是要收取一定的费用，所以我们可以使用修改 hosts 文件来制作一些虚拟域名来使用。需要修改 <code>/etc/hosts</code> 文件来添加</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 hosts 文件</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加内容</span></span><br><span class="line">127.0.0.1 www.frx.com</span><br><span class="line">127.0.0.1 www.bing.com</span><br></pre></td></tr></table></figure>

<ul>
<li>访问测试</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220730/image.3nbv3p1703y0.webp" alt="image"></p>
<blockquote>
<p> <strong>配置方式二：使用通配符配置</strong></p>
</blockquote>
<p>server_name 指令支持通配符 *，但需要注意的是通配符不能出现在域名的中间，只能出现在首段或尾段，如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  <span class="regexp">*.frx.com</span>	<span class="regexp">www.frx.*</span>;</span><br><span class="line">	<span class="comment"># www.frx.cn abc.frx.cn www.bing.cn www.frx.com</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的配置就会报错，因为 * 不能出现在域名的中间和与其他字符串联使用</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  <span class="regexp">www.*</span>.cn www.frx.c*</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span>  .frx.com</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.frx.com</code> 相当于 <code>*..frx.com</code> + <code>frx.com</code></p>
<blockquote>
<p><strong>配置三：使用正则表达式配置</strong></p>
</blockquote>
<p>server_name 指令可以使用正则表达式，并且使用 <code>~</code> 作为正则表达式字符串的开始标记。</p>
<p>常见的正则表达式：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配搜索字符串开始位置</td>
</tr>
<tr>
<td>$</td>
<td>匹配搜索字符串结束位置</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符 \n 之外的任何单个字符</td>
</tr>
<tr>
<td>\</td>
<td>转义字符，将下一个字符标记为特殊字符</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集，与任意一个指定字符匹配</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围，匹配指定范围内的任何字符</td>
</tr>
<tr>
<td>\w</td>
<td>与以下任意字符匹配 A-Z a-z 0-9 和下划线,等效于[A-Za-z0-9_]</td>
</tr>
<tr>
<td>\d</td>
<td>数字字符匹配，等效于[0-9]</td>
</tr>
<tr>
<td>{n}</td>
<td>正好匹配 n 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>至少匹配 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配至少 n 次至多 m 次</td>
</tr>
<tr>
<td>*</td>
<td>零次或多次，等效于{0,}</td>
</tr>
<tr>
<td>+</td>
<td>一次或多次，等效于{1,}</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次，等效于{0,1}</td>
</tr>
</tbody></table>
<p>配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> ~^www\.(\w+)\.com$;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意 ~ 后面不能加空格</strong>。括号代表可以在 Ngxin 配置文件内获取其中的值，如上方的 (\w+) 的内容可以用 $1 获取到参数，如果有多个括号，依次使用 $2 $3 …… 获取。</p>
<p>比如现在访问 <code>http://www.frx.com</code>，则返回 frx 到页面上，因为frx 被放在 $1 处：<code>return 200 frx</code>。</p>
<p>⚠ 这里进行说明：server_name 配置了 localhost 和配置 IP 或者域名的区别</p>
<p>localhost 是「虚拟 IP」，如果不是本机访问，而是外界访问，那么这个就是无效的，但是为什么学习阶段的时候都不改呢，因为当 Nginx 没有匹配到指定的 <code>server_name</code>，默认找到第一个 server 块，而 Nginx 默认的第一个 server 块就是 localhost，哪怕你把 localhost 改为其他的，如 hello，它也能访问。只是因为在匹配不到的情况下，默认是第一个 service 块，哪怕它确实和访问的 IP 不匹配。</p>
<p>IP 如果和域名进行了绑定，那么在 <code>server_name</code> 中，两者都可以填写，填了域名，最后也是找到 IP，只是因为域名好记住。</p>
<p>知道了区别，在生产环境上，可以给个指定的错误页面。如果匹配不上，则返回友好的提示，如第一个 server 块：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;    <span class="comment"># 匹配不上的时候，也可以填写 localhost</span></span><br><span class="line">    <span class="attribute">return</span> <span class="string">"&lt;h1&gt;不好意思，匹配不到！"</span>;</span><br><span class="line">    <span class="comment"># return 403;   # 也可以直接返回错误码</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.frxcat.fun;    <span class="comment"># 匹配域名访问</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码块只允许域名访问，而不允许 IP 访问，避免其他人把未备案的域名解析到自己的服务器 IP。</p>
<p>当然你也可以不设置错误页面。因为 Nginx 匹配不上时，直接返回它的欢迎界面。</p>
<h3 id="匹配执行顺序"><a href="#匹配执行顺序" class="headerlink" title="匹配执行顺序"></a>匹配执行顺序</h3><p>由于 server_name 指令支持通配符和正则表达式，因此在包含多个虚拟主机的配置文件中，可能会出现一个名称被多个虚拟主机的 server_name 匹配成功，当遇到这种情况，当前的请求交给谁来处理呢？如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> ~^www\.\w+\.com$;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'regex_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="regexp">www.frx.*</span>;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'wildcard_after_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="regexp">*.frx.com</span>;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'wildcard_before_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.frx.com;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">200</span> <span class="string">'exact_success'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">	<span class="attribute">server_name</span> _;</span><br><span class="line">	<span class="attribute">default_type</span> text/plain;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">444</span> <span class="string">'default_server not found server'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <code>http://www.kele.com</code> 的优先级：（访问完后请注释掉处理这个请求的 server）</p>
<ul>
<li>exact_success（第一个是精确匹配，然后注释掉该 server）</li>
<li>wildcard_before_success（第二个是开始匹配符，然后注释掉该 server）</li>
<li>wildcard_after_success（第三个是结尾匹配符，然后注释掉该 server）</li>
<li>regex_success（第四个是正则表达式，然后注释掉该 server）</li>
<li>default_server not found server!!（第五个是默认 server，因为前四个都注释了，所以只能走默认的 server）</li>
</ul>
<p><strong>结论</strong></p>
<ul>
<li><p>No1：准确匹配 server_name</p>
</li>
<li><p>No2：通配符在开始时匹配 server_name 成功</p>
</li>
<li><p>No3：通配符在结束时匹配 server_name 成功</p>
</li>
<li><p>No4：正则表达式匹配 server_name 成功</p>
</li>
<li><p>No5：被默认的 default_server 处理，如果没有指定默认找第一个 server</p>
</li>
</ul>
<h3 id="location指令"><a href="#location指令" class="headerlink" title="location指令"></a>location指令</h3><p><code>location</code> 指令是用来设置请求的 URI。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost;</span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="attribute">location</span> /abc &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>location [ = | ~ | <del>* | ^</del> | @ ] &lt;uri&gt;{…}</td>
<td>—</td>
<td>server、location</td>
</tr>
</tbody></table>
<p>uri 变量是待匹配的请求字符串，可以不包含正则表达式，也可以包含正则表达式，那么 Nginx 服务器在搜索匹配 location 的时候，是先使用不包含正则表达式进行匹配，找到一个匹配度最高的一个，然后在通过包含正则表达式的进行匹配，<strong>如果能匹配到直接访问正则表达式的，匹配不到，就使用刚才匹配度最高（前缀最长的）的那个 location 来处理请求</strong>。</p>
<p>属性介绍:</p>
<p>不带符号，要求必须以指定模式开头，但是不要求精确匹配</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> /abc &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下访问都是正确的</span></span><br><span class="line">http://192.168.91.200/abc</span><br><span class="line">http://192.168.91.200/abc?p1=kele</span><br><span class="line">http://192.168.91.200/abc/</span><br><span class="line">http://192.168.91.200/abcdef</span><br></pre></td></tr></table></figure>

<p><code>=</code> 是用于不包含正则表达式的 uri，必须与指定的模式精确匹配</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> =/abc &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 匹配成功</span></span><br><span class="line">http://192.168.91.200/abc</span><br><span class="line">http://192.168.91.200/abc?p1=TOM</span><br><span class="line"><span class="comment"># 匹配失败</span></span><br><span class="line">http://192.168.91.200/abc/</span><br><span class="line">http://192.168.91.200/abcdef</span><br></pre></td></tr></table></figure>

<p><code>~</code> 是用于表示当前 uri 中包含了正则表达式，并且区分大小写</p>
<p><code>~*</code> 是用于表示当前 uri 中包含了正则表达式，但是是不区分大小写</p>
<p>换句话说，<strong>如果 uri 包含了正则表达式，需要用上述两个符号来标识</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用正则表达式，区分大小写</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> ~^/abc\w$ &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式，不区分大小写</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span> ~*^/abc\w$ &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>^~</code> 是用于不包含正则表达式的 uri，功能和不加符号的一致，唯一不同的是，如果请求匹配上了，那么就停止搜索其他模式了。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> <span class="number">127.0.0.1</span>;</span><br><span class="line">	<span class="attribute">location</span><span class="regexp"> ^~/abc</span> &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">200</span> <span class="string">"access success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@</code> 前缀可以用来定义一个命名的 location,该 location 不处理正常的外部请求,一般用来当作标识供内部重定向使用。它们不能嵌套,也不能包含嵌套的 location。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /try &#123;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /error &#123;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> = <span class="variable">@name</span>;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="variable">@name</span> &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">"<span class="variable">@name</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时访问 <code>/try</code> 或者 <code>/error</code> 都会返回 <code>@name</code>。</p>
<h3 id="root-alias指令"><a href="#root-alias指令" class="headerlink" title="root/alias指令"></a>root/alias指令</h3><ul>
<li><code>root</code> 指令是设置请求资源的根目录。默认值是 html。</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>root &lt;path&gt;;</td>
<td>root html;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>path 是 Nginx 服务器接收到请求以后查找资源的根目录路径。</p>
<ul>
<li><code>alias</code> 指令是用来更改 location 的 URI。</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>alias &lt;path&gt;;</td>
<td>—</td>
<td>location</td>
</tr>
</tbody></table>
<ul>
<li>path 是修改后的根路径。</li>
</ul>
<p><strong>以上两个指令都可以来指定访问资源的路径，那么这两者之间的区别是什么？</strong></p>
<blockquote>
<p><strong>举例说明</strong></p>
</blockquote>
<ol>
<li><p>在 <code>/usr/local/nginx/html</code> 目录下创建一个 images 目录,并在目录下放入一张图片 <code>mv.png</code> 图片。</p>
<p>然后进入配置文件，添加如下内容：</p>
</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问图片的路径为：<code>http://192.168.91.200/images/mv.png</code></p>
<ol start="2">
<li>如果把root改为alias</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">alias</span> /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次访问上述地址，页面会出现 404 的错误，查看错误日志会发现是因为地址不对，所以验证了：</p>
<ul>
<li><p>root 的处理结果是：<strong>root 路径 + location 路径</strong>，location 路径包括匹配后面的请求，即包括 /mv.png</p>
<p><code>/usr/local/nginx/html/images/mv.png</code></p>
</li>
</ul>
<ul>
<li>alias 的处理结果是：<strong>使用 alias 路径替换 location 路径</strong>，但是不会替换匹配后面的请求，即不会替换 /mv.png</li>
</ul>
<p>需要在 alias 后面路径改为：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images &#123;</span><br><span class="line">    <span class="attribute">alias</span> /usr/local/nginx/html/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果 location 路径是以 / 结尾,则 alias 也必须是以 / 结尾，root 没有要求。</li>
</ol>
<p>将上述配置修改为：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /images/ &#123;</span><br><span class="line">    <span class="attribute">alias</span> /usr/local/nginx/html/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问就会出问题，查看错误日志还是路径不对，所以需要把 alias 后面加上 /</p>
<p>小结：</p>
<ul>
<li>root 的处理结果是: root 路径 + location 路径</li>
<li>alias 的处理结果是:使用 alias 路径替换 location 路径</li>
<li>alias 是一个目录别名的定义，root 则是最上层目录的含义</li>
<li>如果 location 路径是以 / 结尾,则 alias 也必须是以 / 结尾，root 没有要求<ul>
<li><strong>alias 不支持 location 的 =</strong></li>
</ul>
</li>
</ul>
<p>这里再多言几句，alias 后指定的资源路径，Nginx 就会去这个路径下找资源，「忽略」location 本身的的请求，仅拼接 location 后面的请求。如果你想去拼接 location 本身，就用绝对路径（包括 location）的alias。</p>
<h3 id="index指令"><a href="#index指令" class="headerlink" title="index指令"></a>index指令</h3><p><code>index</code> 指令是设置网站的默认首页。默认是 index.html。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>index &lt;file&gt; …;</td>
<td>index index.html;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p><code>index</code> 后面可以跟多个设置，如果访问的时候没有指定具体访问的资源，则会从左往右依次进行查找，找到第一个为止。</p>
<p>举例说明：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">	<span class="attribute">root</span> /usr/local/nginx/html;</span><br><span class="line">	<span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问该 location 的时候，可以通过 <code>http://ip:port/</code> 访问，地址后面如果不添加任何内容，则默认依次访问 index.html 和 index.htm，找到第一个来进行返回。</p>
<h3 id="error-page指令"><a href="#error-page指令" class="headerlink" title="error_page指令"></a>error_page指令</h3><p>error_page 指令是设置网站的错误页面。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>error_page &lt;code&gt; …… [=[response]] &lt;uri&gt;;</td>
<td>—</td>
<td>http、server、location ……</td>
</tr>
</tbody></table>
<p>code 是响应码。</p>
<p><strong>当出现对应的响应 code 后，如何来处理？</strong></p>
<blockquote>
<p><strong>举例说明</strong></p>
</blockquote>
<ol>
<li>可以指定具体跳转的地址</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> http://www.frx.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当页面产生 404 时，自动跳转到 <code>http://www.frx.com</code></p>
<ol start="2">
<li>可以指定重定向地址</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> /50x.html;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">	<span class="attribute">location</span> =/50x.html &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产生错误页面时，重定向到 /50x.html，然后触发 location，最终访问的是 html 目录下的 50x.html 页面</p>
<ol start="3">
<li>使用 location 的 @ 符合完成错误信息展示</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> <span class="variable">@jump_to_error</span>;</span><br><span class="line">	<span class="attribute">location</span> <span class="variable">@jump_to_error</span> &#123;</span><br><span class="line">		<span class="attribute">default_type</span> text/plain;</span><br><span class="line">		<span class="attribute">return</span> <span class="number">404</span> <span class="string">'Not Found Page...'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可选项 <code>=[response]</code> 的作用是用来将相应代码更改为另外一个，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	<span class="attribute">error_page</span> <span class="number">404</span> =<span class="number">200</span> /50x.html;</span><br><span class="line">	<span class="attribute">location</span> =/50x.html &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，当返回 404 找不到对应的资源的时候，在浏览器上可以看到，最终返回的状态码是 200 而不是 404，这块需要注意下，编写 error_page 后面的内容，404 后面需要加空格，200 前面不能加空格。</p>
<h2 id="静态资源优化配置"><a href="#静态资源优化配置" class="headerlink" title="静态资源优化配置"></a>静态资源优化配置</h2><p>Nginx 对静态资源如何进行优化配置。这里从三个属性配置进行优化：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nodeplay</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>

<p>建议三个都开启。如果想知道为什么，请往下看。</p>
<h3 id="sendﬁle"><a href="#sendﬁle" class="headerlink" title="sendﬁle"></a>sendﬁle</h3><p>该指令是用来开启高效的文件传输模式。默认关闭，建议开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>sendﬁle &lt;on | off&gt;;</td>
<td>sendﬁle oﬀ;</td>
<td>http、server、location ……</td>
</tr>
</tbody></table>
<p>请求静态资源的过程：客户端通过网络接口向服务端发送请求，操作系统将这些客户端的请求传递给服务器端应用程序，服务器端应用程序会处理这些请求，请求处理完成以后，操作系统还需要将处理得到的结果通过网络适配器传递回去。</p>
<p>如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> localhost；</span><br><span class="line">	location / &#123;</span><br><span class="line">		<span class="attribute">root</span> html;</span><br><span class="line">		<span class="attribute">index</span> index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设在 html 目录下有一个 welcome.html 页面，访问地址：<code>http://192.168.91.200/welcome.html</code>。</p>
<p>流程如下：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.24hrbukvg0lc.webp" alt="image"></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.5l2efa1uqlo0.webp" alt="image"></p>
<h3 id="tcp-nopush"><a href="#tcp-nopush" class="headerlink" title="tcp_nopush"></a>tcp_nopush</h3><p>该指令必须在 sendfile 打开的状态下才会生效，主要是用来提升网络包的传输「效率」。默认关闭。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>tcp_nopush &lt;on | off&gt;;</td>
<td>tcp_nopush oﬀ;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<h3 id="tcp-nodelay"><a href="#tcp-nodelay" class="headerlink" title="tcp_nodelay"></a>tcp_nodelay</h3><p>该指令必须在 keep-alive 连接开启的情况下才生效，来提高网络包传输的「实时性」。默认开启。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>tcp_nodelay &lt;on | off&gt;;</td>
<td>tcp_nodelay on;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.1iu7wmocw0ao.webp" alt="image"></p>
<p><code>tcp_nopush</code> 就像大巴车，等所有旅客占满了座位，才开始发车到景点（客户端），而 <code>tcp_nodelay</code>，上来一个旅客，就马上发车到景点客户端）。</p>
<h3 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h3><p>经过分析，『 tcp_nopush 』和『 tcp_nodelay 』看起来是「互斥的」，那么为什么要将这两个值都打开，这个大家需要知道的是在 Linux2.5.9 以后的版本中两者是可以兼容的，三个指令都开启的好处是，sendfile 可以开启高效的文件传输模式，『 tcp_nopush 』开启可以确保在发送到客户端之前数据包已经充分「填满」，这大大减少了网络开销，并加快了文件发送的速度。然后，当它到达最后一个可能因为没有「填满」而暂停的数据包时，Nginx 会忽略『 tcp_nopush 』参数， 然后，『 tcp_nodelay 』强制套接字发送数据。由此可知，『 tcp_nopush 』可以与『 tcp_nodelay 』一起设置，它比单独配置『 tcp_nodelay 』具有更强的性能。</p>
<p>所以回归开头，我们可以使用如下配置来优化 Nginx 静态资源的处理：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三个都开启</span></span><br><span class="line"><span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>

<h2 id="静态资源压缩配置"><a href="#静态资源压缩配置" class="headerlink" title="静态资源压缩配置"></a>静态资源压缩配置</h2><p>经过上述内容的优化，我们再次思考一个问题，假如在满足上述优化的前提下，我们传送一个 1M 的数据和一个 10M 的数据那个效率高？答案显而易见，<strong>传输内容小，速度就会快</strong>。那么问题又来了，同样的内容，如果把大小降下来，我们脑袋里面要蹦出一个词就是「压缩」，接下来，我们来学习 Nginx 的静态资源压缩模块。</p>
<p>在 Nginx 的配置文件中可以通过配置 gzip 来对静态资源进行压缩，相关的指令可以配置在 http 块、server 块和 location 块中，Nginx 可以通过对这些指令进行解析和处理：</p>
<ul>
<li><code>ngx_http_gzip_module</code> 模块</li>
<li><code>ngx_http_gzip_static_module</code> 模块</li>
<li><code>ngx_http_gunzip_module</code> 模块</li>
</ul>
<p>接下来我们从以下内容进行学习：</p>
<ul>
<li>Gzip 各模块支持的配置指令</li>
<li>Gzip 压缩功能的配置</li>
<li>Gzip 和 sendfile 的冲突解决</li>
<li>浏览器不支持 Gzip 的解决方案</li>
</ul>
<h3 id="Gzip模块配置指令"><a href="#Gzip模块配置指令" class="headerlink" title="Gzip模块配置指令"></a>Gzip模块配置指令</h3><p>接下来所学习的指令都来自 <code>ngx_http_gzip_module</code> 模块，该模块会在 Nginx 安装的时候内置到 Nginx 的安装环境中，也就是说我们可以直接使用这些指令。</p>
<ul>
<li><code>gzip</code> 指令是用于开启或者关闭 Gzip 功能。默认关闭</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip &lt;on | off&gt;;</td>
<td>gzip off;</td>
<td>http、server、location ……</td>
</tr>
</tbody></table>
<p>注意：只有该指令为打开状态，下面的指令才有效果</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_types</code> 指令可以根据响应页的 MIME 类型选择性地开启 Gzip 压缩功能。默认是 text/html</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_types &lt;mime-type&gt; …… ;</td>
<td>gzip_types text/html;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>所选择的值可以从 mime.types 文件中进行查找，也可以使用 * 代表所有。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="attribute">gzip_types</span> application/javascript;</span><br><span class="line">	<span class="comment"># * 代表所有</span></span><br><span class="line">	<span class="attribute">gzip_types</span> *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_comp_level</code> 指令是用于设置 Gzip 压缩程度，级别从 1-9，1 表示要是程度最低，要是效率最高，9 刚好相反，压缩程度最高，但是效率最低、最费时间。默认值是 1</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_comp_level &lt;level&gt;;</td>
<td>gzip_comp_level 1;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">	<span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_vary</code> 指令是用于设置使用 Gzip 进行压缩发送是否携带『Vary:Accept-Encoding』头域的响应头部。主要是告诉接收方，所发送的数据经过了 Gzip 压缩处理。默认关闭</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_vary &lt;on | off&gt;;</td>
<td>gzip_vary off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.4bsq0xpu9s20.webp" alt="image"></p>
<ul>
<li><code>gzip_buffers</code> 指令是用于处理请求压缩的缓冲区数量和大小</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_buffers &lt;number&gt; &lt;size&gt;;</td>
<td>gzip_buffers 32 4k | 16 8k;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>其中 number 是指定 Nginx 服务器向系统申请缓存空间个数，size 指的是每个缓存空间的大小。主要实现的是申请 number 个每个大小为 size 的内存空间。这个值的设定一般会和服务器的操作系统有关，所以建议此项不设置，使用默认值即可。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16K</span>;	  <span class="comment"># 缓存空间大小</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>gzip_disable</code> 指令是针对不同种类客户端发起的请求，可以选择性地开启和关闭 Gzip 功能</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_disable &lt;regex&gt; …… ;</td>
<td>—</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>regex 是根据客户端的浏览器标志(user-agent)来设置，支持使用正则表达式。指定的浏览器标志不使用 Gzip.该指令一般是用来排除一些明显不支持 Gzip 的浏览器。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\."</span>;</span><br></pre></td></tr></table></figure>

<p><code>gzip_http_version</code> 指令是针对不同的 HTTP 协议版本，可以选择性地开启和关闭 Gzip 功能。默认是 1.1 版本</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_http_version &lt;1.0 | 1.1&gt;;</td>
<td>gzip_http_version 1.1;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>该指令是指定使用 Gzip 的 HTTP 最低版本，该指令一般采用默认值即可。</p>
<ul>
<li><code>gzip_min_length</code> 指令是针对传输数据的大小，可以选择性地开启和关闭 Gzip 功能</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_min_length &lt;length&gt;;</td>
<td>gzip_min_length 20;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<p>Nignx 计量大小的单位：bytes [字节] / kb [千字节] / M [兆]</p>
<p>例如: 1024 / 10k | K / 10m | M</p>
<p>Gzip 压缩功能对大数据的压缩效果明显，但是如果要压缩的数据比较小的话，可能出现越压缩数据量越大的情况，因此我们需要根据响应内容的大小来决定是否使用 Gzip 功能，响应页面的大小可以通过头信息中的 <code>Content-Length</code> 来获取。但是如何使用了 Chunk 编码动态压缩，该指令将被忽略。建议设置为 1K 或以上。</p>
<ul>
<li><code>gzip_proxied</code> 指令设置是否对服务端返回的结果进行 Gzip 压缩</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_proxied &lt;off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any&gt;;</td>
<td>gzip_proxied off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ul>
<li>off：关闭 Nginx 服务器对后台服务器返回结果的 Gzip 压缩</li>
<li>expired：如果 header 头中包含 『Expires』头信息，启用压缩</li>
<li>no-cache：如果 header 头中包含 『Cache-Control:no-cache』头信息，启用压缩</li>
<li>no-store：如果 header 头中包含 『Cache-Control:no-store』头信息，启用压缩</li>
<li>private：如果 header 头中包含 『Cache-Control:private』头信息，启用压缩</li>
<li>no_last_modified：如果 header 头中不包含 『Last-Modified』头信息，启用压缩</li>
<li>no_etag：如果 header 头中不包含 『ETag』 头信息，启用压缩</li>
<li>auth：如果 header 头中包含 『Authorization』 头信息，启用压缩</li>
<li>any：无条件启用压缩</li>
</ul>
<h3 id="Gzip压缩功能配置模板"><a href="#Gzip压缩功能配置模板" class="headerlink" title="Gzip压缩功能配置模板"></a>Gzip压缩功能配置模板</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;  			   		 <span class="comment"># 开启 Gzip 功能</span></span><br><span class="line"><span class="attribute">gzip_types</span> *;		   	 	 <span class="comment"># 压缩源文件类型,根据具体的访问资源类型设定</span></span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;	   		 <span class="comment"># Gzip 压缩级别</span></span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1k</span>;          <span class="comment"># 进行压缩响应页面的最小长度，content-length</span></span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16K</span>;	         <span class="comment"># 缓存空间大小</span></span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;       <span class="comment"># 指定压缩响应所需要的最低 HTTP 请求版本</span></span><br><span class="line"><span class="attribute">gzip_vary</span>  <span class="literal">on</span>;		         <span class="comment"># 往头信息中添加压缩标识</span></span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\."</span>; <span class="comment"># 对 IE6 以下的版本都不进行压缩</span></span><br><span class="line"><span class="attribute">gzip_proxied</span>  <span class="literal">off</span>;           <span class="comment"># Nginx 作为反向代理压缩服务端返回数据的条件</span></span><br></pre></td></tr></table></figure>

<p>这些配置在很多地方可能都会用到，所以我们可以将这些内容抽取到一个配置文件中，然后通过 include 指令把配置文件再次加载到 nginx.conf 配置文件中，方法使用。</p>
<p>创建压缩配置文件：<code>nginx_gzip.conf</code>，添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> *;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16K</span>;</span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"><span class="attribute">gzip_vary</span>  <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">"MSIE [1-6]\."</span>;</span><br><span class="line"><span class="attribute">gzip_proxied</span>  <span class="literal">off</span>;</span><br></pre></td></tr></table></figure>

<p>在 Nginx 核心配置文件 <code>nginx.conf</code> 进行引入，添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> nginx_gzip.conf</span><br></pre></td></tr></table></figure>

<h3 id="Gzip和sendfile共存问题"><a href="#Gzip和sendfile共存问题" class="headerlink" title="Gzip和sendfile共存问题"></a>Gzip和sendfile共存问题</h3><p>前面在讲解 sendfile 的时候，提到过，开启 sendfile 以后，在读取磁盘上的静态资源文件的时候，可以减少拷贝的次数，可以不经过用户进程将静态文件通过网络设备发送出去，但是 Gzip 要想对资源压缩，是需要经过用户进程进行操作的。Nginx 设置了Gzip 之后，静态文件的 sendfile 就不起作用了。所以要考虑如何解决两个设置的共存问题。</p>
<p>可以使用 <code>ngx_http_gzip_static_module</code> 模块的 <code>gzip_static</code> 指令来解决。</p>
<h3 id="gzip-static指令"><a href="#gzip-static指令" class="headerlink" title="gzip_static指令"></a>gzip_static指令</h3><p><code>gzip_static</code> 指令用于在检查与访问资源同名的 .gz 文件时，response 中以 Gzip 相关的 header 返回 .gz 文件的内容。默认关闭。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>gzip_static &lt;on | off | always&gt;;</td>
<td>gzip_static off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_static</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>

<p>在配置文件添加上述命令后，会报一个错误：<code>unknown directive &quot;gzip_static&quot;</code>，主要的原因是 Nginx 默认是没有添加 ngx_http_gzip_static_module 模块。如何来添加？</p>
<h3 id="Nginx模块添加"><a href="#Nginx模块添加" class="headerlink" title="Nginx模块添加"></a>Nginx模块添加</h3><ol>
<li>查询当前 Nginx 的配置参数，即查看 <code>configure arguments</code> 的配置信息，拷贝出来</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝 configure arguments 后面的数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将 Nginx 安装目录下 sbin 目录中的 nginx 二进制文件进行更名备份</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line">mv nginx nginx.backup</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入 Nginx 的安装目录</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/nginx/core/nginx-1.21.6</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行 make clean 清空之前编译的内容</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用 configure 来配置参数，添加 <code>ngx_http_gzip_static_module</code> 模块，记得加上第1步拷贝的配置信息</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_gzip_static_module  <span class="comment"># 记得添加 configure arguments 后的数据</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>使用 make 命令进行编译</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>将 objs 目录下的 nginx 二进制执行文件移动到 nginx 安装目录下的 sbin 目录中</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /opt/nginx/core/nginx-1.21.6/objs/nginx /usr/<span class="built_in">local</span>/nginx/sbin</span><br></pre></td></tr></table></figure>

<p>如果不执行第（2）步进行备份，则该步骤会覆盖原来的 nginx 可执行文件</p>
<ol start="8">
<li>在源码目录下执行更新命令</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/nginx/core/nginx-1.21.6</span><br><span class="line">make upgrade</span><br></pre></td></tr></table></figure>

<h3 id="gzip-static测试"><a href="#gzip-static测试" class="headerlink" title="gzip_static测试"></a>gzip_static测试</h3><p>准备好一个 jquery.js 文件，放在 html 目录下</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.576ef03x00c0.webp" alt="image"></p>
<ol>
<li>直接访问 <code>http://192.168.91.200/jquery.js</code></li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.2b8dhabn0cbo.webp" alt="image"></p>
<ol start="2">
<li>使用 Gzip 命令进行压缩</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 html 目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩 js 文件</span></span><br><span class="line">gzip jquery.js</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再次访问 <code>http://192.168.91.200/jquery.js</code></li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.4ivj1d091pg.webp" alt="image"></p>
<p>可以看出 <code>Content-Length</code> 的大小已经变得非常小。</p>
<h2 id="静态资源缓存配置"><a href="#静态资源缓存配置" class="headerlink" title="静态资源缓存配置"></a>静态资源缓存配置</h2><p>当浏览器请求 Nginx 服务器的资源后，我们可以让这些资源缓存在浏览器里，这样再一次请求相同的资源时，无需请求 Nginx 服务器，直接从浏览器的缓存里获取，减少 Nginx 服务器的压力。</p>
<h3 id="什么是缓存和Web缓存"><a href="#什么是缓存和Web缓存" class="headerlink" title="什么是缓存和Web缓存"></a>什么是缓存和Web缓存</h3><p>缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用 DRAM 技术，而使用昂贵但较快速的 SRAM 技术。缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。</p>
<p>Web 缓存是指一个 Web 资源（如 html 页面，图片，js，数据等）存在于 Web 服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的 URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 URL 地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。</p>
<h3 id="Web缓存的种类"><a href="#Web缓存的种类" class="headerlink" title="Web缓存的种类"></a>Web缓存的种类</h3><p>客户端缓存</p>
<ul>
<li>浏览器缓存</li>
</ul>
<p>服务端缓存</p>
<ul>
<li>Nginx</li>
<li>Redis</li>
<li>Memcached 等</li>
</ul>
<h3 id="为什么要用浏览器缓存"><a href="#为什么要用浏览器缓存" class="headerlink" title="为什么要用浏览器缓存"></a>为什么要用浏览器缓存</h3><ul>
<li>成本最低的一种缓存实现</li>
<li>减少网络带宽消耗</li>
<li>降低服务器压力</li>
<li>减少网络延迟，加快页面打开速度</li>
</ul>
<h3 id="浏览器缓存执行流程"><a href="#浏览器缓存执行流程" class="headerlink" title="浏览器缓存执行流程"></a>浏览器缓存执行流程</h3><p>HTTP 协议中和页面缓存相关的字段，我们先来认识下：</p>
<table>
<thead>
<tr>
<th>header</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Expires</td>
<td>缓存过期的日期和时间</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>设置和缓存相关的配置信息</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源最后修改时间</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值，比如文件的 MD5 值</td>
</tr>
</tbody></table>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.209c4krjzgf4.webp" alt="image"></p>
<ol>
<li>用户首次通过浏览器发送请求到服务端获取数据，客户端是没有对应的缓存，所以需要发送 request 请求来获取数据；</li>
<li>服务端接收到请求后，获取服务端的数据及服务端缓存的允许后，返回 200 的成功状态码并且在响应头上附上对应资源以及缓存信息；</li>
<li>当用户再次访问相同资源的时候，客户端会在浏览器的缓存目录中查找是否存在响应的缓存文件；</li>
<li>如果没有找到对应的缓存文件，则走第2步；</li>
<li>如果有缓存文件，接下来对缓存文件是否过期进行判断，过期的判断标准是(Expires)；</li>
<li>如果没有过期，则直接从本地缓存中返回数据进行展示（强缓存）；</li>
<li>如果 Expires 过期，接下来需要判断缓存文件是否发生过变化；</li>
<li>判断的标准有两个（都要判断），一个是 ETag(Entity Tag)，一个是 Last-Modified；</li>
<li>判断结果是未发生变化，则服务端返回 304，直接从缓存文件中获取数据（弱缓存）；</li>
<li>如果判断是发生了变化，重新从服务端获取数据，并根据缓存协商(服务端所设置的是否需要进行缓存数据的设置)来进行数据缓存。</li>
</ol>
<h3 id="浏览器缓存相关指令"><a href="#浏览器缓存相关指令" class="headerlink" title="浏览器缓存相关指令"></a>浏览器缓存相关指令</h3><p>Nginx 需要进行缓存相关设置，就需要用到如下的指令。</p>
<h4 id="expires指令"><a href="#expires指令" class="headerlink" title="expires指令"></a>expires指令</h4><p>该指令用来控制页面缓存的作用。可以通过该指令控制 HTTP 应答中的『Expires』和『Cache-Control』</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>expires [modified] &lt;time&gt;; expires &lt;epoch | max | off&gt;;</td>
<td>expires off;</td>
<td>http、server、location</td>
</tr>
</tbody></table>
<ul>
<li><p>time：可以整数也可以是负数，指定过期时间，单位为 s（秒）。如果是负数，Cache-Control 则为 no-cache，如果为整数或 0，则 Cache-Control 的值为 max-age=time</p>
</li>
<li><p>epoch：指定 Expires 的值为『’1 January,1970,00:00:01 GMT’』，即 1970-01-01 00:00:00 ，Cache-Control 的值 no-cache</p>
<p>因为 Expires（缓存过期时间）是 1970 年，所以不缓存。</p>
</li>
<li><p>max：指定 Expires 的值为『’31 December2037 23:59:59GMT’ 』，即(2037-12-31 23:59:59，Cache-Control 的值为 10 年</p>
<p>因为 Expires（缓存过期时间）是 2037 年，虽然还有 16 年过期，但是最大只能缓存 10 年。</p>
</li>
<li><p>off：默认不缓存</p>
</li>
</ul>
<blockquote>
<p><strong>例子 1</strong></p>
</blockquote>
<p>在配置文件添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(html|js|css|png|jpg|jpeg|gif)$</span> &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="attribute">expires</span> max</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送请求：<code>http://192.168.91.200/jquery.js</code></p>
<p>查看开发者工具(F12)的 NetWork，如图：</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220731/image.4x3yczk58lk0.webp" alt="image"></p>
<p>315360000 折算下来正好是 10 年。</p>
<blockquote>
<p><strong>其他格式</strong></p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">expires</span> <span class="number">30s</span>;  <span class="comment"># 表示把数据缓存 30 秒</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">expires</span> <span class="number">30m</span>;  <span class="comment"># 表示把数据缓存 30 分</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">expires</span> <span class="number">10h</span>;  <span class="comment"># 表示把数据缓存 10 小时</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">expires</span> <span class="number">1d</span>;   <span class="comment"># 表示把数据缓存 1 天</span></span><br></pre></td></tr></table></figure>

<h4 id="add-header指令"><a href="#add-header指令" class="headerlink" title="add_header指令"></a>add_header指令</h4><p>add_header 指令是用来添加指定的响应头和响应值。</p>
<p>add_header 是响应体的指令，不是请求时的指令（比如 expires ），并且 add_header 也有和 expires 一样的功能。</p>
<p>如果 expires 和 add_header 同时开启的情况下，则 add_header 优于 expires 生效。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>add_header &lt;name&gt; &lt;value&gt; [always];</td>
<td>—</td>
<td>location &gt; server &gt; http &gt; ……</td>
</tr>
</tbody></table>
<p>always 可选，代表总是添加。</p>
<p>Cache-Control 作为响应头信息，可以在 Nginx 配置文件设置如下缓存响应指令：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">add_header</span> Cache-control must-revalidate;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control <span class="literal">no</span>-cache;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control <span class="literal">no</span>-store;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control <span class="literal">no</span>-transform;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control public;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control private;</span><br><span class="line"><span class="attribute">add_header</span> Cache-control proxy-revalidate;</span><br><span class="line"><span class="attribute">add_header</span> Cache-Control max-age=&lt;seconds&gt;;  <span class="comment"># 秒</span></span><br><span class="line"><span class="attribute">add_header</span> Cache-control s-maxage=&lt;seconds&gt;; <span class="comment"># 秒</span></span><br></pre></td></tr></table></figure>

<p>描述：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>must-revalidate</td>
<td>可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td>no-cache</td>
<td>数据内容不能被缓存，每次请求都重新访问服务器，若有 max-age，则缓存期间不访问服务器</td>
</tr>
<tr>
<td>no-store</td>
<td>不缓存请求或响应的任何内容，暂存也不可以(临时文件夹中不能暂存该资源)</td>
</tr>
<tr>
<td>no-transform</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>public</td>
<td>可以被任何缓存区缓存，如: 浏览器、服务器、代理服务器等</td>
</tr>
<tr>
<td>private（默认）</td>
<td>只能在浏览器中缓存，只有在第一次请求的时候才访问服务器，若有 max-age，则缓存期间不访问服务器</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td>max-age=&lt;秒&gt;</td>
<td>过期时间，即以秒为单位的缓存时间</td>
</tr>
<tr>
<td>s-maxage=&lt;秒&gt;</td>
<td>公共缓存服务器响应的最大 Age 值</td>
</tr>
</tbody></table>
<p>值得注意的是：</p>
<ul>
<li>设置了 no-cache 或者 private 后，打开新窗口时会重新访问服务器。若设置 max-age，则缓存期间不访问服务器</li>
<li>设置 private 和正数的 max-age 时，后退时候不会访问服务器</li>
<li>设置 no-cache 和正数的 max-age 时，后退时会访问服务器</li>
</ul>
<h3 id="Nginx服务端缓存"><a href="#Nginx服务端缓存" class="headerlink" title="Nginx服务端缓存"></a>Nginx服务端缓存</h3><p>在 Web 缓存的种类，我们提到了 Ngixn 服务端缓存，而上面仅仅介绍了在浏览器进行缓存，而因为 Ngixn 服务端缓存的内容比较多，所以前往 <strong>Nginx - 缓存集成</strong> 进行学习。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/3z/wallhaven-3zgz2y.png)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2022 By GeYu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Enjoy the cyber world!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>